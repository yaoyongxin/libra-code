

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>libra_py.workflows.nbra.step2_many_body &mdash; Libra 1.0.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../../index.html" class="icon icon-home"> Libra
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../reference/libra_py.html">libra_py</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Libra</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
        
      <li>libra_py.workflows.nbra.step2_many_body</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for libra_py.workflows.nbra.step2_many_body</h1><div class="highlight"><pre>
<span></span><span class="c1">#*********************************************************************************</span>
<span class="c1">#*</span>
<span class="c1">#* Copyright (C) 2020 Mohammad Shakiba, Brendan Smith, Alexey V. Akimov</span>
<span class="c1">#* This file is distributed under the terms of the GNU General Public License</span>
<span class="c1">#* as published by the Free Software Foundation, either version 3 of</span>
<span class="c1">#* the License, or (at your option) any later version.</span>
<span class="c1">#* See the file LICENSE in the root directory of this distribution</span>
<span class="c1">#* or &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#*</span>
<span class="c1">#*********************************************************************************/</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">.. module:: step2_many_body</span>
<span class="sd">   :platform: Unix, Windows</span>
<span class="sd">   :synopsis: This module implements functions for computing the overlap and nonadiabatic couplings matrices.</span>
<span class="sd">.. moduleauthors:: </span>
<span class="sd">       Mohammad Shakiba, Brendan Smith, Alexey V. Akimov </span>
<span class="sd">  </span>
<span class="sd">&quot;&quot;&quot;</span>



<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span>

<span class="c1"># Concurrency for large systems</span>
<span class="kn">import</span> <span class="nn">concurrent.futures</span>

<span class="kn">from</span> <span class="nn">liblibra_core</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">from</span> <span class="nn">libra_py</span> <span class="kn">import</span> <span class="n">data_conv</span>
<span class="kn">from</span> <span class="nn">libra_py</span> <span class="kn">import</span> <span class="n">cube_file_methods</span>
<span class="kn">from</span> <span class="nn">libra_py</span> <span class="kn">import</span> <span class="n">CP2K_methods</span>
<span class="kn">from</span> <span class="nn">libra_py</span> <span class="kn">import</span> <span class="n">Gaussian_methods</span>
<span class="kn">from</span> <span class="nn">libra_py</span> <span class="kn">import</span> <span class="n">DFTB_methods</span>
<span class="kn">from</span> <span class="nn">libra_py.workflows.nbra</span> <span class="kn">import</span> <span class="n">mapping</span>
<span class="kn">from</span> <span class="nn">libra_py.workflows.nbra</span> <span class="kn">import</span> <span class="n">step3</span>
<span class="kn">from</span> <span class="nn">libra_py</span> <span class="kn">import</span> <span class="n">units</span>

<span class="kn">import</span> <span class="nn">util.libutil</span> <span class="k">as</span> <span class="nn">comn</span>


<span class="c1"># This file is temp only. These functions will eventually be placed in Libra somewhere ...</span>
<div class="viewcode-block" id="curr_and_final_step_job"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step2_many_body.html#libra_py.workflows.nbra.step2_many_body.curr_and_final_step_job">[docs]</a><span class="k">def</span> <span class="nf">curr_and_final_step_job</span><span class="p">(</span> <span class="n">istep</span><span class="p">,</span> <span class="n">fstep</span><span class="p">,</span> <span class="n">njobs</span><span class="p">,</span> <span class="n">njob</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function is used to determine the initial and final step of a job when distributing</span>
<span class="sd">    the molecular dynamics trajectory over a number of jobs.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">    </span>
<span class="sd">        istep (int): The initial time step for molecular dynamics trajectory which </span>
<span class="sd">                     the user wants to start the calculations with. This paramter </span>
<span class="sd">                     is set in the input file for submitting the jobs.</span>
<span class="sd">        </span>
<span class="sd">        fstep (int): The final time step for molecular dynamics trajectory which </span>
<span class="sd">                     the user wants to start the calculations with. This paramter </span>
<span class="sd">                     is set in the input file for submitting the jobs.</span>
<span class="sd">     </span>
<span class="sd">        njobs (int): The number of jobs specified by user.</span>
<span class="sd">        </span>
<span class="sd">        njob (int): The job number.</span>

<span class="sd">    Returns:</span>
<span class="sd">    </span>
<span class="sd">        job_init_step (int): The job initial time step.</span>

<span class="sd">        job_final_step (int): The job final time step.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">total_steps</span> <span class="o">=</span> <span class="n">fstep</span> <span class="o">-</span> <span class="n">istep</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">nsteps_per_job</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">total_steps</span><span class="o">/</span><span class="n">njobs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">njob</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">job_init_step</span>  <span class="o">=</span> <span class="n">istep</span>
        <span class="n">job_final_step</span> <span class="o">=</span> <span class="n">istep</span> <span class="o">+</span> <span class="n">nsteps_per_job</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">elif</span> <span class="n">njob</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">njob</span> <span class="o">&lt;</span> <span class="p">(</span> <span class="n">njobs</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">):</span>
        <span class="n">job_init_step</span>  <span class="o">=</span> <span class="n">istep</span> <span class="o">+</span> <span class="n">njob</span> <span class="o">*</span> <span class="n">nsteps_per_job</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">job_final_step</span> <span class="o">=</span> <span class="n">istep</span> <span class="o">+</span> <span class="p">(</span> <span class="n">njob</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="o">*</span> <span class="n">nsteps_per_job</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">elif</span> <span class="n">njob</span> <span class="o">==</span> <span class="p">(</span> <span class="n">njobs</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">):</span>
        <span class="n">job_init_step</span>  <span class="o">=</span> <span class="n">istep</span> <span class="o">+</span> <span class="n">njob</span> <span class="o">*</span> <span class="n">nsteps_per_job</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">job_final_step</span> <span class="o">=</span> <span class="n">fstep</span>

    <span class="k">return</span> <span class="n">job_init_step</span><span class="p">,</span> <span class="n">job_final_step</span></div>





<div class="viewcode-block" id="normalize_ci_coefficients"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step2_many_body.html#libra_py.workflows.nbra.step2_many_body.normalize_ci_coefficients">[docs]</a><span class="k">def</span> <span class="nf">normalize_ci_coefficients</span><span class="p">(</span><span class="n">ci_coefficients_raw_unnorm</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This funciton normalizes the list of configuration interaction (CI) coefficients.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">    </span>
<span class="sd">        ci_coefficients_raw_unnorm (list): The list containing the lists of unnormalized CI coefficients.</span>

<span class="sd">    Returns:</span>
<span class="sd">    </span>
<span class="sd">        ci_coefficients_raw_norm (list): The list containing the lists of normalized CI coefficients.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Number of states contributing in the excited state</span>
    <span class="n">nstates</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ci_coefficients_raw_unnorm</span><span class="p">)</span>
    <span class="c1"># Creating an empty list to store the normalized CI coefficients</span>
    <span class="n">ci_coefficients_raw_norm</span> <span class="o">=</span> <span class="p">[]</span>
       
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nstates</span><span class="p">):</span>
        
        <span class="c1">#### ordinary way without using numpy</span>
        <span class="c1"># Set up an initial parameter to compute the norm of the vector</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="c1"># For each list of CI coefficients</span>
        <span class="n">ci_coefficients_raw_norm</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">[]</span> <span class="p">)</span>
        
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ci_coefficients_raw_unnorm</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="c1"># sum of CI coefficients square</span>
            <span class="n">norm</span> <span class="o">+=</span> <span class="n">j</span><span class="o">*</span><span class="n">j</span>
        <span class="c1"># Compute the norm by taking the square root of the sum to compute the norm</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
        
        <span class="c1"># numpy way to compute the normalized CI coefficients</span>
        <span class="n">ci_coefficients_raw_unnorm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ci_coefficients_raw_unnorm</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">ci_coefficients_raw_norm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>   <span class="o">=</span> <span class="n">ci_coefficients_raw_unnorm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">norm</span>
        <span class="n">ci_coefficients_raw_norm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>   <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ci_coefficients_raw_norm</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> 
    
    <span class="k">return</span> <span class="n">ci_coefficients_raw_norm</span></div>





<div class="viewcode-block" id="get_excitation_analysis_output"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step2_many_body.html#libra_py.workflows.nbra.step2_many_body.get_excitation_analysis_output">[docs]</a><span class="k">def</span> <span class="nf">get_excitation_analysis_output</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function reads the information of the excited states from the log file of the single point calculations.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">    </span>
<span class="sd">        params (dict):</span>

<span class="sd">            logfile_directory (str): The log files directory.</span>

<span class="sd">            es_software (str): The name of the software used to calculate the energy calculations.</span>
<span class="sd">        </span>
<span class="sd">            curr_step (int): The current time step of the calculations.</span>
<span class="sd">            </span>
<span class="sd">            isUKS (int): This parameter is set for spin restricted and unrestricted calculations. When it is</span>
<span class="sd">                         set to 1 it means that unrestricted calculations were set in the input file otherwise </span>
<span class="sd">                         it is restricted.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    </span>
<span class="sd">        excitation_energies (numpy array): The excitation energies of the curr_step.</span>

<span class="sd">        ci_basis_raw (numpy array): The excited states which contains the occupied and virtual orbitals.</span>

<span class="sd">        ci_coefficients_raw_unnorm (numpy array): The excited states CI coefficients.</span>

<span class="sd">        spin_components (numpy array): Contains the excited states spin components (&#39;alp&#39; for alpha spin and &#39;bet&#39; for beta spin)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">critical_params</span> <span class="o">=</span> <span class="p">[</span> <span class="s2">&quot;curr_step&quot;</span> <span class="p">]</span>
    <span class="c1"># Default parameters</span>
    <span class="n">default_params</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;isUKS&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;es_software&quot;</span><span class="p">:</span> <span class="s2">&quot;cp2k&quot;</span><span class="p">,</span> <span class="s2">&quot;logfile_directory&quot;</span><span class="p">:</span> <span class="s2">&quot;logfiles&quot;</span> <span class="p">}</span>
    <span class="c1"># Check input</span>
    <span class="n">comn</span><span class="o">.</span><span class="n">check_input</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">default_params</span><span class="p">,</span> <span class="n">critical_params</span><span class="p">)</span>
    
    <span class="n">logfile_directory</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;logfile_directory&quot;</span><span class="p">]</span>
    <span class="n">es_software</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;es_software&quot;</span><span class="p">]</span>
    <span class="n">curr_step</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;curr_step&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">es_software</span> <span class="o">==</span> <span class="s2">&quot;cp2k&quot;</span><span class="p">:</span>
        
        <span class="n">logfile_name</span> <span class="o">=</span> <span class="sa">F</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">logfile_directory</span><span class="si">}</span><span class="s2">/step_</span><span class="si">{</span><span class="n">curr_step</span><span class="si">}</span><span class="s2">.log&quot;</span>
        <span class="n">params</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;logfile_name&quot;</span><span class="p">:</span><span class="n">logfile_name</span><span class="p">})</span> 
        <span class="c1"># Extract the excitation energies and their configurations from the output file.</span>
        <span class="n">excitation_energies</span><span class="p">,</span> <span class="n">ci_basis_raw</span><span class="p">,</span> <span class="n">ci_coefficients_raw_unnorm</span><span class="p">,</span> <span class="n">spin_components</span> <span class="o">=</span> \
        <span class="n">CP2K_methods</span><span class="o">.</span><span class="n">read_cp2k_tddfpt_log_file</span><span class="p">(</span> <span class="n">params</span> <span class="p">)</span>

    <span class="k">elif</span> <span class="n">es_software</span> <span class="o">==</span> <span class="s2">&quot;gaussian&quot;</span><span class="p">:</span>

        <span class="n">logfile_name</span> <span class="o">=</span> <span class="sa">F</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">logfile_directory</span><span class="si">}</span><span class="s2">/step_</span><span class="si">{</span><span class="n">curr_step</span><span class="si">}</span><span class="s2">.log&quot;</span>
        <span class="n">params</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;logfile_name&quot;</span><span class="p">:</span><span class="n">logfile_name</span><span class="p">})</span> 
        <span class="n">excitation_energies</span><span class="p">,</span> <span class="n">ci_basis_raw</span><span class="p">,</span> <span class="n">ci_coefficients_raw_unnorm</span><span class="p">,</span> <span class="n">spin_components</span> <span class="o">=</span> \
        <span class="n">Gaussian_methods</span><span class="o">.</span><span class="n">read_gaussian_tddft_log_file</span><span class="p">(</span> <span class="n">params</span> <span class="p">)</span>

    <span class="k">elif</span> <span class="n">es_software</span> <span class="o">==</span> <span class="s2">&quot;dftb+&quot;</span><span class="p">:</span>

        <span class="n">logfile_name</span> <span class="o">=</span> <span class="sa">F</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">logfile_directory</span><span class="si">}</span><span class="s2">/TRA_</span><span class="si">{</span><span class="n">curr_step</span><span class="si">}</span><span class="s2">.DAT&quot;</span>
        <span class="n">params</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;logfile_name&quot;</span><span class="p">:</span><span class="n">logfile_name</span><span class="p">})</span>
        <span class="n">excitation_energies</span><span class="p">,</span> <span class="n">ci_basis_raw</span><span class="p">,</span> <span class="n">ci_coefficients_raw_unnorm</span><span class="p">,</span> <span class="n">spin_components</span> <span class="o">=</span> \
        <span class="n">DFTB_methods</span><span class="o">.</span><span class="n">read_dftbplus_TRA_file</span><span class="p">(</span> <span class="n">params</span> <span class="p">)</span>
  
    <span class="k">return</span> <span class="n">excitation_energies</span><span class="p">,</span> <span class="n">ci_basis_raw</span><span class="p">,</span> <span class="n">ci_coefficients_raw_unnorm</span><span class="p">,</span> <span class="n">spin_components</span></div>




<div class="viewcode-block" id="integrate_cube_set"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step2_many_body.html#libra_py.workflows.nbra.step2_many_body.integrate_cube_set">[docs]</a><span class="k">def</span> <span class="nf">integrate_cube_set</span><span class="p">(</span> <span class="n">cubefiles_set_1</span><span class="p">,</span> <span class="n">cubefiles_set_2</span><span class="p">,</span> <span class="n">dv</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function comutes the overlap matrix between two set of cube files.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">    </span>
<span class="sd">        cubefiles_set_1 (list): The list of cube files of the curr_step.</span>

<span class="sd">        cubefiles_set_2 (list): The list of cube files of the previous step.</span>

<span class="sd">        dv (float): The integration element obtained from the cube files.</span>

<span class="sd">    Returns:</span>
<span class="sd">    </span>
<span class="sd">        overlap_matrix (numpy 2D array): The overlap between the two set of cube files.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialize the overlap matrix</span>
    <span class="c1"># Note: The overlap matrix is a square matrix so the cubefiles_set_1 and cubefiles_set_2 must have the same length</span>
    <span class="n">overlap_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">cubefiles_set_2</span> <span class="p">)</span> <span class="p">,</span> <span class="nb">len</span><span class="p">(</span> <span class="n">cubefiles_set_1</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>

    <span class="c1"># The overlaps between the cube files of the first set and second set</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span> <span class="n">cubefiles_set_2</span> <span class="p">)</span> <span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span> <span class="n">cubefiles_set_1</span> <span class="p">)</span> <span class="p">):</span>
            <span class="c1"># Use the integrate_cube to compute the integration between the wavefunctions.</span>
            <span class="n">overlap_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">cube_file_methods</span><span class="o">.</span><span class="n">integrate_cube</span><span class="p">(</span> <span class="n">cubefiles_set_2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cubefiles_set_1</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">dv</span> <span class="p">)</span>

    <span class="k">return</span> <span class="n">overlap_matrix</span></div>





<div class="viewcode-block" id="compute_cube_ks_overlaps"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step2_many_body.html#libra_py.workflows.nbra.step2_many_body.compute_cube_ks_overlaps">[docs]</a><span class="k">def</span> <span class="nf">compute_cube_ks_overlaps</span><span class="p">(</span> <span class="n">cubefiles_prev</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function computes overlaps between cube files of two time steps. In order to not read the cube files </span>
<span class="sd">    twice it returns the cube files of the current step, and gets the cube files of the previous step.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">    </span>
<span class="sd">        cubefiles_prev (list): The list containing th cube files of the previous step.</span>

<span class="sd">        params (dict):</span>

<span class="sd">            curr_step (int): The current time step.</span>

<span class="sd">            isUKS (int): This parameter is set for spin restricted and unrestricted calculations. When it is</span>
<span class="sd">                         set to 1 it means that unrestricted calculations were set in the input file otherwise </span>
<span class="sd">                         it is restricted.</span>
<span class="sd">            </span>
<span class="sd">            nprocs (int): The number of processors used to read the cube files and perform the integration.</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">    </span>
<span class="sd">        cubefiles_curr (list): The list of the read current step cube files.</span>
<span class="sd">        </span>
<span class="sd">        S_ks_prev (2D numpy array): The overlap matrix of the wavefunctions for the previous time step.</span>
<span class="sd">        </span>
<span class="sd">        S_ks_curr (2D numpy array): The overlap matrix of the wavefunctions for the current time step.</span>
<span class="sd">        </span>
<span class="sd">        St_ks (2D numpy array): The overlap matrix between wavefunctions of the two time step.</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">critical_params</span> <span class="o">=</span> <span class="p">[</span> <span class="s2">&quot;curr_step&quot;</span><span class="p">,</span> <span class="s2">&quot;nprocs&quot;</span> <span class="p">]</span>
    <span class="c1"># Default parameters</span>
    <span class="n">default_params</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;isUKS&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;es_software&quot;</span><span class="p">:</span> <span class="s2">&quot;cp2k&quot;</span><span class="p">}</span>
    <span class="c1"># Check input</span>
    <span class="n">comn</span><span class="o">.</span><span class="n">check_input</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">default_params</span><span class="p">,</span> <span class="n">critical_params</span><span class="p">)</span>
    <span class="c1"># Extract the variables</span>
    <span class="n">curr_step</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;curr_step&quot;</span><span class="p">])</span>
    <span class="n">isUKS</span>  <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;isUKS&quot;</span><span class="p">])</span>
    <span class="n">nprocs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;nprocs&quot;</span><span class="p">])</span>
    <span class="n">es_software</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;es_software&quot;</span><span class="p">]</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;---------------------------------------------------------&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Starting the calculations by reading the cube files    </span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;                    Step time </span><span class="si">%i</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">%</span><span class="p">(</span><span class="n">curr_step</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-------------------------------------------------------</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Reading cube files with </span><span class="si">%i</span><span class="s1"> number of processors&#39;</span><span class="o">%</span><span class="n">nprocs</span><span class="p">)</span>
    <span class="c1"># First read all the .cube files (This is the most time consuming part)</span>
    <span class="c1"># Creating a pool and assigning the number of processors for mp.Pool</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">nprocs</span><span class="p">)</span>
    
    <span class="c1"># for curr_step</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Reading the cubes for step &quot;</span><span class="p">,</span> <span class="n">curr_step</span><span class="p">)</span>
    <span class="c1"># generate the cube file names produced by CP2K</span>
    <span class="n">cubefile_names_curr</span> <span class="o">=</span> <span class="n">CP2K_methods</span><span class="o">.</span><span class="n">cube_file_names_cp2k</span><span class="p">(</span> <span class="n">params</span> <span class="p">)</span>

    <span class="c1">#for cubefile in cubefile_names_curr:</span>
    <span class="c1">#    os.system( &quot;/gpfs/scratch/brendan/cp2k/tools/cubecruncher/cubecruncher.x -center geo -i %s -o %s-1.cube &quot; % ( cubefile, cubefile.replace( &quot;.cube&quot;, &quot;&quot; ) ) )</span>
    <span class="c1">#    os.system( &quot;rm %s&quot; % cubefile)</span>
    <span class="c1">#    os.system( &quot;mv %s-1.cube %s&quot; % ( cubefile.replace(&quot;.cube&quot;,&quot;&quot;), cubefile ) )</span>

    <span class="c1"># Reading the cube files</span>
    <span class="n">cubefiles_curr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Apply pool.map to the cube_file_methods to the set of variables of the cubefile_names_curr</span>
    <span class="n">cubefiles_curr</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span> <span class="n">cube_file_methods</span><span class="o">.</span><span class="n">read_cube</span><span class="p">,</span> <span class="n">cubefile_names_curr</span> <span class="p">)</span>
    <span class="c1"># Close the pool</span>
    <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="c1"># Calculate the dv element for integration</span>
    <span class="n">dv</span> <span class="o">=</span> <span class="n">cube_file_methods</span><span class="o">.</span><span class="n">grid_volume</span><span class="p">(</span> <span class="n">cubefile_names_curr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>

    <span class="c1">#### Compute the overlaps</span>
    <span class="c1"># If spin unrestricted calculations were set to run</span>
    <span class="k">if</span> <span class="n">isUKS</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

        <span class="c1"># The cube files for alpha and beta spin for the previous time step</span>

        <span class="c1"># The alpha cubes are the even indices of the read cube files</span>
        <span class="n">alp_cubes_prev</span> <span class="o">=</span> <span class="n">cubefiles_prev</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
        <span class="c1"># The beta cubes are the odd indices of the read cube files</span>
        <span class="n">bet_cubes_prev</span> <span class="o">=</span> <span class="n">cubefiles_prev</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
    
        <span class="c1"># The cube files for alpha and beta spin for the current time step</span>

        <span class="c1"># The alpha cubes are the even indices of the read cube files</span>
        <span class="n">alp_cubes_curr</span> <span class="o">=</span> <span class="n">cubefiles_curr</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
        <span class="c1"># The beta cubes are the odd indices of the read cube files</span>
        <span class="n">bet_cubes_curr</span> <span class="o">=</span> <span class="n">cubefiles_curr</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># Initializing the overlap matrices for alpha and beta spin with zero matrices</span>
        <span class="n">zero_mat_alp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">alp_cubes_prev</span> <span class="p">),</span> <span class="nb">len</span><span class="p">(</span> <span class="n">alp_cubes_curr</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">zero_mat_bet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">bet_cubes_prev</span> <span class="p">),</span> <span class="nb">len</span><span class="p">(</span> <span class="n">bet_cubes_curr</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>


        <span class="c1">### Using concurrency to compute the integration and overlap matrices</span>
        <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="n">nprocs</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
            <span class="c1"># &lt;psi_alp(t-1)|psi_alp(t)&gt;</span>
            <span class="n">int_1</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">integrate_cube_set</span><span class="p">,</span> <span class="n">alp_cubes_prev</span><span class="p">,</span> <span class="n">alp_cubes_curr</span><span class="p">,</span> <span class="n">dv</span> <span class="p">)</span>
            <span class="c1"># &lt;psi_bet(t-1)|psi_bet(t)&gt;</span>
            <span class="n">int_2</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">integrate_cube_set</span><span class="p">,</span> <span class="n">bet_cubes_prev</span><span class="p">,</span> <span class="n">bet_cubes_curr</span><span class="p">,</span> <span class="n">dv</span> <span class="p">)</span>
            <span class="c1"># &lt;psi_alp(t-1)|psi_alp(t-1)&gt;</span>
            <span class="n">int_3</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">integrate_cube_set</span><span class="p">,</span> <span class="n">alp_cubes_prev</span><span class="p">,</span> <span class="n">alp_cubes_prev</span><span class="p">,</span> <span class="n">dv</span> <span class="p">)</span>
            <span class="c1"># &lt;psi_bet(t-1)|psi_bet(t-1)&gt;</span>
            <span class="n">int_4</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">integrate_cube_set</span><span class="p">,</span> <span class="n">bet_cubes_prev</span><span class="p">,</span> <span class="n">bet_cubes_prev</span><span class="p">,</span> <span class="n">dv</span> <span class="p">)</span>
            <span class="c1"># &lt;psi_alp(t)|psi_alp(t)&gt;</span>
            <span class="n">int_5</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">integrate_cube_set</span><span class="p">,</span> <span class="n">alp_cubes_curr</span><span class="p">,</span> <span class="n">alp_cubes_curr</span><span class="p">,</span> <span class="n">dv</span> <span class="p">)</span>
            <span class="c1"># &lt;psi_bet(t)|psi_bet(t)&gt;</span>
            <span class="n">int_6</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">integrate_cube_set</span><span class="p">,</span> <span class="n">bet_cubes_curr</span><span class="p">,</span> <span class="n">bet_cubes_curr</span><span class="p">,</span> <span class="n">dv</span> <span class="p">)</span>

        <span class="c1"># Extracting the results for each of the submitted jobs</span>
        <span class="n">St_alp_alp</span> <span class="o">=</span> <span class="n">int_1</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
        <span class="n">St_bet_bet</span> <span class="o">=</span> <span class="n">int_2</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

        <span class="c1"># The overlap between cube files at times t-1 and t</span>
        <span class="n">S_alp_alp_prev</span> <span class="o">=</span> <span class="n">int_3</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
        <span class="n">S_bet_bet_prev</span> <span class="o">=</span> <span class="n">int_4</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
        <span class="n">S_alp_alp_curr</span> <span class="o">=</span> <span class="n">int_5</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
        <span class="n">S_bet_bet_curr</span> <span class="o">=</span> <span class="n">int_6</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="c1">### Using the concurrency</span>
        <span class="k">with</span> <span class="n">concurrent</span><span class="o">.</span><span class="n">futures</span><span class="o">.</span><span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="n">nprocs</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
            <span class="c1"># &lt;psi(t-1)|psi(t-1)&gt;</span>
            <span class="n">int_1</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">integrate_cube_set</span><span class="p">,</span> <span class="n">cubefiles_prev</span><span class="p">,</span> <span class="n">cubefiles_prev</span><span class="p">,</span> <span class="n">dv</span> <span class="p">)</span>
            <span class="c1"># &lt;psi(t)|psi(t)&gt;</span>
            <span class="n">int_2</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">integrate_cube_set</span><span class="p">,</span> <span class="n">cubefiles_curr</span><span class="p">,</span> <span class="n">cubefiles_curr</span><span class="p">,</span> <span class="n">dv</span> <span class="p">)</span>
            <span class="c1"># &lt;psi(t-1)|psi(t)&gt;</span>
            <span class="n">int_3</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">integrate_cube_set</span><span class="p">,</span> <span class="n">cubefiles_prev</span><span class="p">,</span> <span class="n">cubefiles_curr</span><span class="p">,</span> <span class="n">dv</span> <span class="p">)</span>

        <span class="c1"># Extracting the results</span>
        <span class="n">S_prev</span> <span class="o">=</span> <span class="n">int_1</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
        <span class="n">S_curr</span> <span class="o">=</span> <span class="n">int_2</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>
        <span class="n">St</span>     <span class="o">=</span> <span class="n">int_3</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

        <span class="c1"># These are used to form the block matrices for two-spinor format </span>
        <span class="n">zero_mat_alp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">S_prev</span> <span class="p">),</span> <span class="nb">len</span><span class="p">(</span> <span class="n">S_curr</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">zero_mat_bet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">S_prev</span> <span class="p">),</span> <span class="nb">len</span><span class="p">(</span> <span class="n">S_curr</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>

        <span class="c1"># The alpha and beta spin have the same overlap matrix in spin restricted case</span>
        <span class="n">S_alp_alp_prev</span><span class="p">,</span> <span class="n">S_bet_bet_prev</span> <span class="o">=</span> <span class="n">S_prev</span><span class="p">,</span> <span class="n">S_prev</span>
        <span class="n">S_alp_alp_curr</span><span class="p">,</span> <span class="n">S_bet_bet_curr</span> <span class="o">=</span> <span class="n">S_curr</span><span class="p">,</span> <span class="n">S_curr</span>
        <span class="n">St_alp_alp</span><span class="p">,</span> <span class="n">St_bet_bet</span> <span class="o">=</span> <span class="n">St</span><span class="p">,</span> <span class="n">St</span>
    
    <span class="c1"># Storing the overlap matices in two-spinor format by forming the block matrices</span>
    <span class="n">S_ks_prev</span> <span class="o">=</span> <span class="n">data_conv</span><span class="o">.</span><span class="n">form_block_matrix</span><span class="p">(</span> <span class="n">S_alp_alp_prev</span><span class="p">,</span> <span class="n">zero_mat_alp</span><span class="p">,</span> <span class="n">zero_mat_bet</span><span class="p">,</span> <span class="n">S_bet_bet_prev</span> <span class="p">)</span>
    <span class="n">S_ks_curr</span> <span class="o">=</span> <span class="n">data_conv</span><span class="o">.</span><span class="n">form_block_matrix</span><span class="p">(</span> <span class="n">S_alp_alp_curr</span><span class="p">,</span> <span class="n">zero_mat_alp</span><span class="p">,</span> <span class="n">zero_mat_bet</span><span class="p">,</span> <span class="n">S_bet_bet_curr</span> <span class="p">)</span>
    <span class="n">St_ks</span>     <span class="o">=</span> <span class="n">data_conv</span><span class="o">.</span><span class="n">form_block_matrix</span><span class="p">(</span> <span class="n">St_alp_alp</span><span class="p">,</span>     <span class="n">zero_mat_alp</span><span class="p">,</span> <span class="n">zero_mat_bet</span><span class="p">,</span> <span class="n">St_bet_bet</span> <span class="p">)</span>

    <span class="k">return</span> <span class="n">cubefiles_curr</span><span class="p">,</span> <span class="n">S_ks_prev</span><span class="p">,</span> <span class="n">S_ks_curr</span><span class="p">,</span> <span class="n">St_ks</span> </div>




<div class="viewcode-block" id="reindex_cp2k_sd_states"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step2_many_body.html#libra_py.workflows.nbra.step2_many_body.reindex_cp2k_sd_states">[docs]</a><span class="k">def</span> <span class="nf">reindex_cp2k_sd_states</span><span class="p">(</span> <span class="n">ks_orbital_homo_index</span><span class="p">,</span> <span class="n">ks_orbital_indicies</span><span class="p">,</span> <span class="n">sd_basis_states</span><span class="p">,</span> <span class="n">sd_format</span><span class="o">=</span><span class="mi">2</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ks_orbital_homo_index: Index of the homo ks orbital, from 1</span>
<span class="sd">    ks_orbital_indicies: Range of the considered ks orbtials. Ex) [8,9,10,11], where 9 is homo orbtial index (from 1)</span>
<span class="sd">    sd_basis_states( list of lists of lists ): A list of Slater determinants, where each slater determinant is a excitation in the Kohn-Sham</span>
<span class="sd">                                               basis. This function assumes that all Kohn-Sham excitations are for alpha electrons. To</span>
<span class="sd">                                               differentiate between alpha and beta excitations, elements of sd_basis_states contain spin</span>
<span class="sd">                                               information.</span>
<span class="sd">               </span>
<span class="sd">                                               Ex) sd_basis_states[0] = [ [9,10], &quot;alp&quot; ] </span>
<span class="sd">                                                   sd_basis_states[1] = [ [9,10], &quot;bet&quot; ]</span>
<span class="sd">    Returns:</span>
<span class="sd">         Reindexed Slater determinant basis states in terms of the ks_orbital_homo_index. The SD states returned can be either in one of two ways</span>

<span class="sd">         1. All alpha orbitals before beta orbtials. This format is still a fixed slot format. It is used when used both alpha and beta spin channels</span>
<span class="sd">         Ex.)   ks_orbital_homo_index = 68,    ks_orbital_indicies = [67, 68, 69, 70, 71, 72]</span>
<span class="sd">                The ground state will be: [1, 2, -7, -8]</span>
<span class="sd">                [ [68,69], &quot;alp&quot; ] --&gt; [1, 3, -7, -8]</span>
<span class="sd">                [ [68,69], &quot;bet&quot; ] --&gt; [1, 2, -7, -9]</span>

<span class="sd">         2. Fixed slot format. this format used only the alpha spin channel</span>
<span class="sd">         Ex.)   ks_orbital_homo_index = 68,    ks_orbital_indicies = [67, 68, 69, 70, 71, 72]</span>
<span class="sd">                The ground state will be: [1, -1, 2, -2]</span>
<span class="sd">                [ [68,69], &quot;alp&quot; ] --&gt; [1, -1, 3, -2]</span>
<span class="sd">                [ [68,69], &quot;bet&quot; ] --&gt; [1, -1, 2, -3]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Entered reindex_cp2k_sd_states function&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ks_orbital_homo_index&quot;</span><span class="p">,</span> <span class="n">ks_orbital_homo_index</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ks_orbital_indicies&quot;</span><span class="p">,</span> <span class="n">ks_orbital_indicies</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;sd_basis_states&quot;</span><span class="p">,</span> <span class="n">sd_basis_states</span><span class="p">)</span>

    <span class="c1"># We need to update the indexing of the sd_basis - in terms of the rows and cols of St_KS</span>
    <span class="c1"># reindex ks orbs according to the matrix size</span>
    <span class="n">n_alp_ks_orbs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ks_orbital_indicies</span><span class="p">)</span>
    <span class="n">alp_homo_matrix_index</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">n_alp_ks_orbs</span> <span class="p">):</span>
        <span class="k">if</span> <span class="n">ks_orbital_indicies</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">ks_orbital_homo_index</span><span class="p">:</span>
            <span class="n">alp_homo_matrix_index</span> <span class="o">=</span> <span class="n">i</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;alp_homo_matrix_index&quot;</span><span class="p">,</span><span class="n">alp_homo_matrix_index</span><span class="p">)</span>

    <span class="n">ks_orbs_new_index</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">n_alp_ks_orbs</span> <span class="p">):</span>
        <span class="n">ks_orbs_new_index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="p">)</span>

    <span class="c1"># Form excited state SDs</span>
    <span class="n">excitations</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># For each Slater determinant basis state, which could have spin_component &quot;alp&quot; or &quot;bet&quot;</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">sd_basis_states</span> <span class="p">)</span> <span class="p">):</span>

        <span class="nb">print</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span> <span class="n">sd_basis_states</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span> <span class="n">sd_basis_states</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">))</span>

        <span class="k">if</span> <span class="n">sd_format</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sd_basis_states</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;alp&quot;</span><span class="p">:</span>
                <span class="n">initial_ks_orb</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">sd_basis_states</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span> <span class="o">-</span> <span class="n">ks_orbital_homo_index</span> <span class="o">+</span> <span class="n">alp_homo_matrix_index</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">final_ks_orb</span>   <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">sd_basis_states</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="o">-</span> <span class="n">ks_orbital_homo_index</span> <span class="o">+</span> <span class="n">alp_homo_matrix_index</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">sd_basis_states</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;bet&quot;</span><span class="p">:</span>
                <span class="n">initial_ks_orb</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">sd_basis_states</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span> <span class="o">-</span> <span class="n">ks_orbital_homo_index</span> <span class="o">+</span> <span class="n">alp_homo_matrix_index</span> <span class="o">+</span> <span class="n">n_alp_ks_orbs</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">final_ks_orb</span>   <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">sd_basis_states</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="o">-</span> <span class="n">ks_orbital_homo_index</span> <span class="o">+</span> <span class="n">alp_homo_matrix_index</span> <span class="o">+</span> <span class="n">n_alp_ks_orbs</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">elif</span> <span class="n">sd_format</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  
            <span class="n">initial_ks_orb</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">sd_basis_states</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span> <span class="o">-</span> <span class="n">ks_orbital_homo_index</span> <span class="o">+</span> <span class="n">alp_homo_matrix_index</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">final_ks_orb</span>   <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">sd_basis_states</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="o">-</span> <span class="n">ks_orbital_homo_index</span> <span class="o">+</span> <span class="n">alp_homo_matrix_index</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">sd_basis_states</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;alp&quot;</span><span class="p">:</span>
            <span class="n">excitations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">[</span><span class="n">initial_ks_orb</span><span class="p">,</span> <span class="n">final_ks_orb</span><span class="p">]</span>  <span class="p">)</span>
    
        <span class="k">elif</span> <span class="n">sd_basis_states</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;bet&quot;</span><span class="p">:</span>
            <span class="n">excitations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">[</span><span class="o">-</span><span class="n">initial_ks_orb</span><span class="p">,</span> <span class="o">-</span><span class="n">final_ks_orb</span><span class="p">]</span>  <span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;excitations = &quot;</span><span class="p">,</span> <span class="n">excitations</span> <span class="p">)</span>
    <span class="c1">#sys.exit(0)</span>

    <span class="c1"># Form ground-state SD first</span>
    <span class="n">sd_basis</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[]</span> <span class="p">]</span>
    <span class="k">if</span> <span class="n">sd_format</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span> <span class="n">ks_orbital_indicies</span> <span class="p">)</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">alp_homo_matrix_index</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">sd_basis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">i</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">n_alp_ks_orbs</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_alp_ks_orbs</span> <span class="o">+</span> <span class="n">alp_homo_matrix_index</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">sd_basis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="o">-</span><span class="n">i</span> <span class="p">)</span>

    <span class="k">elif</span> <span class="n">sd_format</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span> <span class="n">ks_orbital_indicies</span> <span class="p">)</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">alp_homo_matrix_index</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">sd_basis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>  <span class="n">i</span> <span class="p">)</span>
                <span class="n">sd_basis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="o">-</span><span class="n">i</span> <span class="p">)</span>
    <span class="nb">print</span> <span class="p">(</span> <span class="s2">&quot;ground state = &quot;</span><span class="p">,</span> <span class="n">sd_basis</span> <span class="p">)</span>

    <span class="c1"># Now that we have done the ground state slater </span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">excitations</span> <span class="p">)</span> <span class="p">):</span>
        <span class="n">sd_excitation</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sd_state</span> <span class="ow">in</span> <span class="n">sd_basis</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">sd_state</span><span class="o">==</span><span class="n">excitations</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">sd_excitation</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">excitations</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sd_excitation</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sd_state</span><span class="p">)</span>
        <span class="n">sd_basis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">sd_excitation</span> <span class="p">)</span>
    <span class="nb">print</span> <span class="p">(</span> <span class="n">sd_basis</span> <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">sd_basis</span></div>




<div class="viewcode-block" id="apply_state_reordering_ci"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step2_many_body.html#libra_py.workflows.nbra.step2_many_body.apply_state_reordering_ci">[docs]</a><span class="k">def</span> <span class="nf">apply_state_reordering_ci</span><span class="p">(</span><span class="n">St</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs the state&#39;s identity reordering in a given basis for all time steps.</span>
<span class="sd">    This is reflects in the corresponding changess of the TDM.</span>
<span class="sd">    Args:</span>
<span class="sd">        St ( list of CMATRIX(nstates, nstates) ): TDM for each timestep</span>
<span class="sd">        E ( list of CMATRIX(nstates, nstates) ): energies of all states at every step</span>
<span class="sd">        params ( dictionary ): parameters controlling the reordering</span>
<span class="sd">            * **params[&quot;do_state_reordering&quot;]** ( int ): option to select the state reordering algorithm </span>
<span class="sd">                Available options:</span>
<span class="sd">                    - 1: older version developed by Kosuke Sato, may not the working all the times</span>
<span class="sd">                    - 2: Munkres-Kuhn (Hungarian) method [default]</span>
<span class="sd">            * **params[&quot;state_reordering_alpha&quot;]** ( double ): a parameter that controls how </span>
<span class="sd">                many states will be included in the reordering</span>
<span class="sd">    Returns:</span>
<span class="sd">        None: but changes the input St object</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">critical_params</span> <span class="o">=</span> <span class="p">[</span> <span class="p">]</span>
    <span class="n">default_params</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;do_state_reordering&quot;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;state_reordering_alpha&quot;</span><span class="p">:</span><span class="mf">0.0</span> <span class="p">}</span>
    <span class="n">comn</span><span class="o">.</span><span class="n">check_input</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">default_params</span><span class="p">,</span> <span class="n">critical_params</span><span class="p">)</span>

    <span class="n">nsteps</span>  <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">St</span><span class="p">)</span>
    <span class="n">nstates</span> <span class="o">=</span> <span class="n">St</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">num_of_cols</span> 

    <span class="c1"># Initialize the cumulative permutation as the identity permutation</span>
    <span class="n">perm_cum</span> <span class="o">=</span> <span class="n">intList</span><span class="p">()</span> <span class="c1"># cumulative permutation for alpha spatial orbitals</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">):</span>
        <span class="n">perm_cum</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="c1"># Current permutation</span>
    <span class="n">perm_t</span> <span class="o">=</span> <span class="n">intList</span><span class="p">()</span> 
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nstates</span><span class="p">):</span>
        <span class="n">perm_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
 
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nsteps</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;do_state_reordering&quot;</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            A simple approach based on permuations - but this is not robust</span>
<span class="sd">            may have loops</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">perm_t</span> <span class="o">=</span> <span class="n">get_reordering</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="c1"># apply the cumulative permutation  </span>
            <span class="n">update_permutation</span><span class="p">(</span><span class="n">perm_t</span><span class="p">,</span> <span class="n">perm_cum</span><span class="p">)</span>

            <span class="c1"># apply the permutation</span>
            <span class="c1"># Because St = &lt;psi(t)|psi(t+dt)&gt; - we permute only columns</span>
            <span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">permute_cols</span><span class="p">(</span><span class="n">perm_cum</span><span class="p">)</span>

            <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">permute_cols</span><span class="p">(</span><span class="n">perm_cum</span><span class="p">)</span>
            <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">permute_rows</span><span class="p">(</span><span class="n">perm_cum</span><span class="p">)</span>


        <span class="k">elif</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;do_state_reordering&quot;</span><span class="p">]</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            The Hungarian approach</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># Permute rows for this time-step</span>
            <span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">permute_rows</span><span class="p">(</span><span class="n">perm_t</span><span class="p">)</span>

            <span class="c1"># compute the cost matrices</span>
            <span class="n">cost_mat</span> <span class="o">=</span> <span class="n">make_cost_mat</span><span class="p">(</span><span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;state_reordering_alpha&quot;</span><span class="p">])</span>

            <span class="c1"># Solve the optimal assignment problem for this time-step</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">hungarian</span><span class="o">.</span><span class="n">maximize</span><span class="p">(</span><span class="n">cost_mat</span><span class="p">)</span>

            <span class="c1"># Convert the list of lists into the permutation object</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">res</span><span class="p">:</span>
                <span class="n">perm_t</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># for &lt; i | i &gt; this becomes a new value: perm_t = P_{n+1}</span>

            <span class="c1"># Permute the blocks by col</span>
            <span class="n">St</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">permute_cols</span><span class="p">(</span><span class="n">perm_t</span><span class="p">)</span></div>




<div class="viewcode-block" id="form_Hvib_real"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step2_many_body.html#libra_py.workflows.nbra.step2_many_body.form_Hvib_real">[docs]</a><span class="k">def</span> <span class="nf">form_Hvib_real</span><span class="p">(</span> <span class="n">params</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function forms the real part of the vibronic Hamiltonian by inserting the </span>
<span class="sd">    energies on the diagonal of a zero matrix. The Hvib is in two-spinor format </span>
<span class="sd">    containing the alpha and beta states energies.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        </span>
<span class="sd">        params (distionary):</span>

<span class="sd">            logfile_directory (str): The directory of the output files by CP2K.</span>

<span class="sd">            time (int): The time step of the molecular dynamics. For single point calculations</span>
<span class="sd">                        it should be set to 0.</span>
<span class="sd">                    </span>
<span class="sd">            min_band (int): The minimum state number.</span>

<span class="sd">            max_band (int): The maximum state number.</span>
<span class="sd"> </span>
<span class="sd">            isUKS (int): This flag is used whenever the UKS calculations were called in CP2K input. if it is set to</span>
<span class="sd">                         1 then UKS calculations were called and if not it will consider only alpha energies.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">    </span>
<span class="sd">        Hvib_ks_re (2D numpy array): The diagonal matrix containing the energies of alpha and beta spins if</span>
<span class="sd">                                     UKS is set to True and the energies of alpha spin in a block form matrix.</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">critical_params</span> <span class="o">=</span> <span class="p">[</span> <span class="s2">&quot;min_band&quot;</span><span class="p">,</span> <span class="s2">&quot;max_band&quot;</span><span class="p">,</span> <span class="s2">&quot;curr_step&quot;</span> <span class="p">]</span>
    <span class="c1"># Default parameters</span>
    <span class="n">default_params</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;isUKS&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;es_software&quot;</span><span class="p">:</span> <span class="s2">&quot;cp2k&quot;</span><span class="p">,</span> <span class="s2">&quot;logfile_directory&quot;</span><span class="p">:</span> <span class="s2">&quot;logfiles&quot;</span><span class="p">}</span>
    <span class="c1"># Check input</span>
    <span class="n">comn</span><span class="o">.</span><span class="n">check_input</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">default_params</span><span class="p">,</span> <span class="n">critical_params</span><span class="p">)</span>
    <span class="c1"># Extracting the data</span>

    <span class="n">isUKS</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;isUKS&quot;</span><span class="p">]</span> <span class="p">)</span>
    <span class="c1"># ks_orbital_indicies = params[&quot;ks_orbital_indicies&quot;]</span>
    <span class="n">es_software</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;es_software&quot;</span><span class="p">]</span>
    <span class="c1"># minimum state</span>
    <span class="n">min_band</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;min_band&quot;</span><span class="p">]</span> <span class="c1"># ks_orbital_indicies[0]</span>
    <span class="c1"># maximum state</span>
    <span class="n">max_band</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;max_band&quot;</span><span class="p">]</span> <span class="c1"># ks_orbital_indicies[-1]</span>
    <span class="c1"># log file directory</span>
    <span class="n">logfile_directory</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;logfile_directory&quot;</span><span class="p">]</span>
    <span class="c1"># current time step</span>
    <span class="n">curr_step</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;curr_step&quot;</span><span class="p">]</span>
    <span class="c1"># generate the log file name</span>
    <span class="n">logfile_name</span> <span class="o">=</span> <span class="sa">F</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">logfile_directory</span><span class="si">}</span><span class="s2">/step_</span><span class="si">{</span><span class="n">curr_step</span><span class="si">}</span><span class="s2">.log&quot;</span>
    <span class="c1"># update the logfile_name parameter in params</span>
    <span class="n">params</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;logfile_name&quot;</span><span class="p">:</span><span class="n">logfile_name</span><span class="p">})</span>

    <span class="c1"># If the UKS calculations were set to True in CP2K input</span>
    <span class="k">if</span> <span class="n">isUKS</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Read energies with alpha spin</span>
        <span class="k">if</span> <span class="n">es_software</span> <span class="o">==</span> <span class="s2">&quot;cp2k&quot;</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;spin&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">E_alpha</span><span class="p">,</span> <span class="n">total_energy</span> <span class="o">=</span> <span class="n">CP2K_methods</span><span class="o">.</span><span class="n">read_energies_from_cp2k_log_file</span><span class="p">(</span> <span class="n">params</span> <span class="p">)</span>
            <span class="c1"># Read energies with beta spin</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;spin&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">E_beta</span><span class="p">,</span> <span class="n">total_energy</span> <span class="o">=</span> <span class="n">CP2K_methods</span><span class="o">.</span><span class="n">read_energies_from_cp2k_log_file</span><span class="p">(</span> <span class="n">params</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">es_software</span> <span class="o">==</span> <span class="s2">&quot;gaussian&quot;</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;spin&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">E_alpha</span><span class="p">,</span> <span class="n">total_energy</span> <span class="o">=</span> <span class="n">Gaussian_methods</span><span class="o">.</span><span class="n">read_energies_from_gaussian_log_file</span><span class="p">(</span> <span class="n">params</span> <span class="p">)</span>
            <span class="c1"># Read energies with beta spin</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;spin&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="n">E_beta</span><span class="p">,</span> <span class="n">total_energy</span> <span class="o">=</span> <span class="n">Gaussian_methods</span><span class="o">.</span><span class="n">read_energies_from_gaussian_log_file</span><span class="p">(</span> <span class="n">params</span> <span class="p">)</span>
        <span class="c1"># Now forming the diagonal matrix containing the Kohn-Sham energies of the alpha and beta spins</span>
        <span class="n">Hvib_ks_re</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span> <span class="p">(</span> <span class="n">E_alpha</span><span class="p">,</span> <span class="n">E_beta</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
    <span class="c1"># If there is no UKS calculations set</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">es_software</span> <span class="o">==</span> <span class="s2">&quot;cp2k&quot;</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;spin&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="c1"># spin = 1</span>
            <span class="n">E_alpha</span><span class="p">,</span> <span class="n">total_energy</span> <span class="o">=</span> <span class="n">CP2K_methods</span><span class="o">.</span><span class="n">read_energies_from_cp2k_log_file</span><span class="p">(</span> <span class="n">params</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">es_software</span> <span class="o">==</span> <span class="s2">&quot;gaussian&quot;</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;spin&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">E_alpha</span><span class="p">,</span> <span class="n">total_energy</span> <span class="o">=</span> <span class="n">Gaussian_methods</span><span class="o">.</span><span class="n">read_energies_from_gaussian_log_file</span><span class="p">(</span> <span class="n">params</span> <span class="p">)</span>
        <span class="k">elif</span> <span class="n">es_software</span> <span class="o">==</span> <span class="s2">&quot;dftb+&quot;</span><span class="p">:</span>
            <span class="c1"># generate the log file name</span>
            <span class="n">logfile_name</span> <span class="o">=</span> <span class="sa">F</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">logfile_directory</span><span class="si">}</span><span class="s2">/step_</span><span class="si">{</span><span class="n">curr_step</span><span class="si">}</span><span class="s2">_ks.log&quot;</span>
            <span class="c1"># update the logfile_name parameter in params</span>
            <span class="n">params</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;logfile_name&quot;</span><span class="p">:</span><span class="n">logfile_name</span><span class="p">})</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;spin&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">E_alpha</span><span class="p">,</span> <span class="n">total_energy</span> <span class="o">=</span> <span class="n">DFTB_methods</span><span class="o">.</span><span class="n">get_dftb_ks_energies</span><span class="p">(</span> <span class="n">params</span> <span class="p">)</span>
        <span class="n">Hvib_ks_re</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span> <span class="p">(</span> <span class="n">E_alpha</span><span class="p">,</span> <span class="n">E_alpha</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">Hvib_ks_re</span><span class="p">,</span> <span class="n">total_energy</span></div>



<div class="viewcode-block" id="run_step2_many_body"><a class="viewcode-back" href="../../../../reference/libra_py/workflows/nbra/step2_many_body.html#libra_py.workflows.nbra.step2_many_body.run_step2_many_body">[docs]</a><span class="k">def</span> <span class="nf">run_step2_many_body</span><span class="p">(</span> <span class="n">params</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function is the main function which runs the following calculations:</span>

<span class="sd">    * performin CP2K calculations</span>
<span class="sd">    * computing the overlap matrices</span>
<span class="sd">    * molecular orbital energies</span>
<span class="sd">    * nonadiabatic couplings in Kohn-Sham and TD-DFPT level of theory</span>
<span class="sd">    * molecular orbital visualization using VMD</span>
<span class="sd">    * phase correction and state reordering</span>

<span class="sd">    then it will print out all the outputs.</span>

<span class="sd">    * Note: The current code works with CP2K but it can be generalized to other electronic structure</span>
<span class="sd">            calculation software packages which are capable of producing cube files and performing </span>
<span class="sd">            TD-DFT calculations such as Gaussian. So this parameter is for future implementations.</span>

<span class="sd">    Args:</span>

<span class="sd">        params (dictionary):</span>

<span class="sd">            min_band (integer): The minimum state number.</span>

<span class="sd">            max_band (integer): The maximum state number.</span>

<span class="sd">            ks_orbital_homo_index (integer): The index of the Kohn-Sham HOMO orbital (State numbers start from 1).</span>

<span class="sd">            nsteps_this_job (integer): The number of steps in this job.</span>

<span class="sd">            es_software (string): The electronic structure calculation software.</span>

<span class="sd">                    * Note: The current code works with CP2K but it can be generalized to other electronic structure</span>
<span class="sd">                            calculation software packages which are capable of producing cube files and performing </span>
<span class="sd">                            TD-DFT calculations such as Gaussian. So this parameter is for future implementations.</span>

<span class="sd">            es_software_exe (string): The CP2K executable file or path.</span>

<span class="sd">            es_software_input_template (str): The full path to CP2K input template.</span>

<span class="sd">            project_name (string): The project name for CP2K input.</span>

<span class="sd">            isUKS (integer): This is the flag for unrestricted spin calculations. When it is set to</span>
<span class="sd">                             1 it will perform the nrestricted calculations otherwise it will consider the restricted case.</span>

<span class="sd">            trajectory_xyz_filename (string): The full path to trajectory xyz file.</span>

<span class="sd">            njob (integer): The current job number.</span>

<span class="sd">            nprocs (integer): The number of processors to be used.</span>

<span class="sd">            res_dir (string): The full path to res directory where the output data are stored.</span>

<span class="sd">            dt (float): The time step in atomic unit used in molecular dynamics calculations.</span>

<span class="sd">            logfile_directory (string): The path to where the log files are stored.</span>

<span class="sd">            number_of_states (integer): The number of excited states to be considered in the TD-DFPT calculations.</span>

<span class="sd">            tolerance (float): This float number is used to consider only the states which their </span>
<span class="sd">                               square CI coefficients is larger than tolerance factor.</span>

<span class="sd">            do_phase_corrections (integer): This flag is for phase correction of the overlap matrices. If it is set to</span>
<span class="sd">                                            1 it will perform phase correction otherwise it will not.</span>

<span class="sd">            </span>

<span class="sd">    Returns:</span>

<span class="sd">        None</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Current working directory</span>
    <span class="n">pwd</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
    <span class="c1"># Critical variables</span>
    <span class="n">critical_params</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;min_band&quot;</span><span class="p">,</span> <span class="s2">&quot;max_band&quot;</span><span class="p">,</span> <span class="s2">&quot;ks_orbital_homo_index&quot;</span><span class="p">,</span> <span class="s2">&quot;nsteps_this_job&quot;</span><span class="p">,</span> <span class="s1">&#39;trajectory_xyz_filename&#39;</span><span class="p">]</span>
    <span class="c1"># Default parameters</span>
    <span class="n">default_params</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&quot;isUKS&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;es_software&quot;</span><span class="p">:</span> <span class="s2">&quot;cp2k&quot;</span><span class="p">,</span> <span class="s2">&quot;es_software_exe&quot;</span><span class="p">:</span> <span class="s2">&quot;cp2k.psmp&quot;</span><span class="p">,</span> <span class="s2">&quot;es_software_input_template&quot;</span><span class="p">:</span> <span class="s2">&quot;cp2k_input_template.inp&quot;</span><span class="p">,</span> <span class="s2">&quot;project_name&quot;</span><span class="p">:</span> <span class="s2">&quot;Libra_CP2K&quot;</span><span class="p">,</span> <span class="s2">&quot;njob&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;nprocs&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;dt&quot;</span><span class="p">:</span>  <span class="mf">41.3393964448119</span><span class="p">,</span> <span class="s2">&quot;logfile_directory&quot;</span><span class="p">:</span> <span class="s2">&quot;logfiles&quot;</span><span class="p">,</span> <span class="s2">&quot;number_of_states&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;tolerance&quot;</span><span class="p">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s2">&quot;do_phase_corrections&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;istep&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;do_cube_visualization&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;states_to_be_plotted&quot;</span><span class="p">:</span> <span class="p">[]</span> <span class="p">}</span>
    <span class="c1"># Check input</span>
    <span class="n">comn</span><span class="o">.</span><span class="n">check_input</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">default_params</span><span class="p">,</span> <span class="n">critical_params</span><span class="p">)</span>
   

    <span class="c1"># Extracting the min_band and max_band, we have to use int(...) since </span>
    <span class="c1"># the numbers which are read from the bash are strings.</span>
    <span class="n">min_band</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;min_band&quot;</span><span class="p">]</span> <span class="p">)</span>
    <span class="n">max_band</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;max_band&quot;</span><span class="p">]</span> <span class="p">)</span>
    <span class="c1"># Update params with min_band and max_band</span>
    <span class="n">params</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;min_band&quot;</span><span class="p">:</span><span class="n">min_band</span><span class="p">})</span>
    <span class="n">params</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;max_band&quot;</span><span class="p">:</span><span class="n">max_band</span><span class="p">})</span>

    <span class="c1"># Define ks_orbital_indicies based on the min_band and max_band    </span>
    <span class="n">ks_orbital_indicies</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="nb">range</span><span class="p">(</span> <span class="n">min_band</span><span class="p">,</span> <span class="n">max_band</span><span class="o">+</span><span class="mi">1</span> <span class="p">)</span> <span class="p">)</span>
    <span class="c1"># Update params with ks_orbital_indicies</span>
    <span class="n">params</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;ks_orbital_indicies&quot;</span><span class="p">:</span><span class="n">ks_orbital_indicies</span><span class="p">})</span>

    <span class="c1"># The HOMO orbital index </span>
    <span class="n">ks_orbital_homo_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;ks_orbital_homo_index&quot;</span><span class="p">])</span>

    <span class="c1"># Number of steps for this job</span>
    <span class="n">nsteps_this_job</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;nsteps_this_job&quot;</span><span class="p">])</span>
    <span class="n">es_software</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;es_software&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="n">params</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="p">{</span><span class="s2">&quot;es_software&quot;</span><span class="p">:</span> <span class="n">es_software</span><span class="p">}</span> <span class="p">)</span>

    <span class="c1"># The electronic structure software, for example cp2k</span>
    <span class="k">if</span> <span class="n">es_software</span> <span class="o">==</span> <span class="s2">&quot;cp2k&quot;</span><span class="p">:</span>
        <span class="c1"># The path to executable CP2K</span>
        <span class="n">cp2k_exe</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;es_software_exe&quot;</span><span class="p">]</span>
        <span class="n">cp2k_input_template</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;es_software_input_template&quot;</span><span class="p">]</span>

    <span class="k">elif</span> <span class="n">es_software</span> <span class="o">==</span> <span class="s2">&quot;gaussian&quot;</span><span class="p">:</span>
        <span class="n">gaussian_exe</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;es_software_exe&quot;</span><span class="p">]</span>
        <span class="n">gaussian_input_template</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;es_software_input_template&quot;</span><span class="p">]</span>

    <span class="k">elif</span> <span class="n">es_software</span> <span class="o">==</span> <span class="s2">&quot;dftb+&quot;</span><span class="p">:</span>
        <span class="n">dftbp_exe</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;es_software_exe&quot;</span><span class="p">]</span>
        <span class="n">dftb_input_template</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;es_software_input_template&quot;</span><span class="p">]</span>

    <span class="c1"># The project name, this is important since the cube files are produced based on the project_name</span>
    <span class="n">project_name</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;project_name&quot;</span><span class="p">]</span>
    <span class="c1"># The path to the pre-computed trajectory</span>
    <span class="n">trajectory_xyz_filename</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;trajectory_xyz_filename&quot;</span><span class="p">]</span>
    <span class="c1"># The job number</span>
    <span class="n">njob</span>    <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;njob&quot;</span><span class="p">])</span>
    <span class="c1"># The number of processors</span>
    <span class="n">nprocs</span>  <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;nprocs&quot;</span><span class="p">])</span>
    <span class="c1"># Update params with nprocs</span>
    <span class="n">params</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;nprocs&quot;</span><span class="p">:</span><span class="n">nprocs</span><span class="p">})</span>

    <span class="c1"># The path to res directory where the overlap matrices, energies, and NACs are stored</span>
    <span class="n">res_dir</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;res_dir&quot;</span><span class="p">]</span>

    <span class="c1"># The time step in atomic unit, used to compute the NACs</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">])</span>

    <span class="c1"># The path to log files produced by CP2K</span>
    <span class="n">logfile_directory</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;logfile_directory&quot;</span><span class="p">]</span>

    <span class="c1"># Number of excited states</span>
    <span class="n">number_of_states</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;number_of_states&quot;</span><span class="p">])</span>
    <span class="c1"># The tolerance factor for CI coefficients</span>
    <span class="n">tolerance</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;tolerance&quot;</span><span class="p">])</span>    

    <span class="c1"># Phase corection flag</span>
    <span class="n">do_phase_corrections</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;do_phase_corrections&quot;</span><span class="p">])</span>

    <span class="c1"># The current time step which here is set to istep</span>
    <span class="n">curr_step</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;istep&quot;</span><span class="p">])</span>
    <span class="c1"># Update the curr_step in params</span>
    <span class="n">params</span><span class="o">.</span><span class="n">update</span><span class="p">({</span> <span class="s2">&quot;curr_step&quot;</span><span class="p">:</span> <span class="n">curr_step</span> <span class="p">})</span>

    <span class="c1"># Cube file visualization flag</span>
    <span class="n">do_cube_visualization</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;do_cube_visualization&quot;</span><span class="p">])</span>

    <span class="c1"># Flag for the completion level</span>
    <span class="n">completion_level</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;completion_level&quot;</span><span class="p">])</span> 


    <span class="c1">#####################################################################################################</span>
    <span class="c1">######################## Initializing lists for storing the data for each job #######################</span>
    <span class="c1">#####################################################################################################</span>
    <span class="c1"># For empty lists for the KS, SD, and CI bases. These are to be used for collecting data at each step</span>

    <span class="c1"># Overlap of the wavefunctions at the same time step in this job</span>
    <span class="n">S_ks_job</span>  <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Overlap of the wavefunctions for two consecutive time steps in this job</span>
    <span class="n">St_ks_job</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Energy levels of the molecular orbitals for each time step in this job</span>
    <span class="n">E_ks_job</span>  <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># The total energies for each time step in this job</span>
    <span class="n">total_energies_job</span> <span class="o">=</span> <span class="p">[]</span> 

    <span class="c1"># The overlap matrices for Slater determinant basis for each time step in this job</span>
    <span class="n">S_sd_job</span>  <span class="o">=</span> <span class="p">[]</span>
    <span class="n">St_sd_job</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># The unique basis of Slater determinants basis</span>
    <span class="n">sd_basis_states_unique</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># The overlap matrices for excited states for each time step in this job</span>
    <span class="n">S_ci_job</span>  <span class="o">=</span> <span class="p">[]</span>
    <span class="n">St_ci_job</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># The configuration interaction coefficients, energies, and basis states with their spin components for each time step in this job</span>
    <span class="n">ci_coefficients_job</span>   <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ci_basis_states_job</span>   <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ci_energies_job</span>       <span class="o">=</span> <span class="p">[]</span>
    <span class="n">spin_components_job</span>   <span class="o">=</span> <span class="p">[]</span>

    <span class="c1">####### Setting up the calculations for the initial step</span>

    <span class="n">timer1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="c1"># Set up an initial parameter to compute the norm of the vector</span>

    <span class="k">if</span> <span class="n">es_software</span> <span class="o">==</span> <span class="s2">&quot;cp2k&quot;</span><span class="p">:</span>

        <span class="c1"># Set up the cp2k input template with the atomic positions for the first timestep of this job batch</span>
        <span class="n">CP2K_methods</span><span class="o">.</span><span class="n">CP2K_input_static</span><span class="p">(</span> <span class="n">cp2k_input_template</span><span class="p">,</span> <span class="n">project_name</span><span class="p">,</span> <span class="n">trajectory_xyz_filename</span><span class="p">,</span> <span class="n">curr_step</span> <span class="p">)</span>
        <span class="c1"># Running the CP2K calculations</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;mpirun -np </span><span class="si">%d</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> -i </span><span class="si">%s</span><span class="s2">-</span><span class="si">%i</span><span class="s2">.inp -o logfiles/step_</span><span class="si">%d</span><span class="s2">.log &quot;</span><span class="o">%</span><span class="p">(</span> <span class="n">nprocs</span><span class="p">,</span> <span class="n">cp2k_exe</span><span class="p">,</span> <span class="n">project_name</span><span class="p">,</span> <span class="n">curr_step</span><span class="p">,</span> <span class="n">curr_step</span> <span class="p">)</span> <span class="p">)</span>
        <span class="c1"># After finishing the CP2K calculations move all the pdos and cube files to specified folders</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;mv *.pdos pdosfiles&quot;</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">es_software</span> <span class="o">==</span> <span class="s2">&quot;gaussian&quot;</span><span class="p">:</span>

        <span class="n">Gaussian_methods</span><span class="o">.</span><span class="n">gaussian_input</span><span class="p">(</span> <span class="n">project_name</span><span class="p">,</span> <span class="n">curr_step</span><span class="p">,</span> <span class="n">gaussian_input_template</span><span class="p">,</span> <span class="n">trajectory_xyz_filename</span> <span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> &lt; </span><span class="si">%s</span><span class="s2">-</span><span class="si">%i</span><span class="s2">.gjf &gt; logfiles/step_</span><span class="si">%d</span><span class="s2">.log &quot;</span><span class="o">%</span><span class="p">(</span> <span class="n">gaussian_exe</span><span class="p">,</span> <span class="n">project_name</span><span class="p">,</span> <span class="n">curr_step</span><span class="p">,</span> <span class="n">curr_step</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">Gaussian_methods</span><span class="o">.</span><span class="n">cube_generator_gaussian</span><span class="p">(</span><span class="n">project_name</span><span class="p">,</span><span class="n">curr_step</span><span class="p">,</span><span class="n">ks_orbital_indicies</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ks_orbital_indicies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">nprocs</span><span class="p">,</span><span class="s1">&#39;../../sample_cube_file.cube&#39;</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;isUKS&quot;</span><span class="p">]))</span>

    <span class="k">elif</span> <span class="n">es_software</span> <span class="o">==</span> <span class="s2">&quot;dftb+&quot;</span><span class="p">:</span>

        <span class="nb">print</span><span class="p">(</span> <span class="s1">&#39;params[&quot;curr_step&quot;]&#39;</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;curr_step&quot;</span><span class="p">])</span>
        <span class="c1"># Set up the dftb+ input template.</span>
        <span class="n">DFTB_methods</span><span class="o">.</span><span class="n">make_dftb_input</span><span class="p">(</span> <span class="n">dftb_input_template</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;curr_step&quot;</span><span class="p">]</span>  <span class="p">)</span>
        <span class="c1"># Convert the xyz file for currstep to the .gen file format</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;xyz2gen coord-&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;curr_step&quot;</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;.xyz&quot;</span><span class="p">)</span>
        <span class="c1"># Run the dftb+ program</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;srun </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span> <span class="n">dftbp_exe</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;mv band.out step_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">curr_step</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_ks.log&quot;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;mv step_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">curr_step</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_ks.log logfiles/.&quot;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;mv EXC.DAT EXC_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">curr_step</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;.DAT&quot;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;mv EXC_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">curr_step</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;.DAT logfiles/.&quot;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;mv TRA.DAT TRA_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">curr_step</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;.DAT&quot;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;mv TRA_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">curr_step</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;.DAT logfiles/.&quot;</span><span class="p">)</span>
        <span class="n">DFTB_methods</span><span class="o">.</span><span class="n">cube_generator_dftbplus</span><span class="p">(</span> <span class="n">project_name</span><span class="p">,</span> <span class="n">curr_step</span><span class="p">,</span> <span class="n">ks_orbital_indicies</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ks_orbital_indicies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;/util/academic/dftbplus/19.1-arpack/bin/waveplot&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;isUKS&quot;</span><span class="p">])</span> <span class="p">)</span>

    <span class="c1">#sys.exit(0)</span>

    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;mv *.cube cubefiles&quot;</span><span class="p">)</span>
    <span class="c1"># Print the elapsed time for CP2K calculations for this step.</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;es_software&quot;</span><span class="p">],</span><span class="s2">&quot; calculation time for step &quot;</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;curr_step&quot;</span><span class="p">],</span><span class="s2">&quot; was &quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">timer1</span><span class="p">)</span>

    <span class="c1"># We have compted the first SCF calculation for this job, now to read the output data and cubes</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Reading the initial step using pool&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;nprocs&quot;</span><span class="p">,</span> <span class="n">nprocs</span><span class="p">)</span>
    <span class="c1"># Creating a pool with nprocs</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span> <span class="n">processes</span> <span class="o">=</span> <span class="n">nprocs</span> <span class="p">)</span>

    <span class="c1"># The cube file names produced by CP2K, Here we set it as prev since we</span>
    <span class="c1"># don&#39;t want to read the cubes twice.</span>
    <span class="n">cubefile_names_prev</span> <span class="o">=</span> <span class="n">CP2K_methods</span><span class="o">.</span><span class="n">cube_file_names_cp2k</span><span class="p">(</span> <span class="n">params</span> <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Initial step for this job, the cube file names are:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">cubefile_names_prev</span><span class="p">)</span>
    <span class="c1"># We may have to &quot;crunch&quot; the cubes - this may be especially needed for periodic systems.</span>
    <span class="c1">#for cubefile in cubefile_names_prev:</span>
    <span class="c1">#    os.system( &quot;/gpfs/scratch/brendan/cp2k/tools/cubecruncher/cubecruncher.x -center geo -i %s -o %s-1.cube &quot; % ( cubefile, cubefile.replace( &quot;.cube&quot;, &quot;&quot; ) ) )</span>
    <span class="c1">#    os.system( &quot;rm %s&quot; % cubefile)</span>
    <span class="c1">#    os.system( &quot;mv %s-1.cube %s&quot; % ( cubefile.replace(&quot;.cube&quot;,&quot;&quot;), cubefile ) )</span>
    <span class="n">cubefiles_prev</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span> <span class="n">cube_file_methods</span><span class="o">.</span><span class="n">read_cube</span><span class="p">,</span> <span class="n">cubefile_names_prev</span> <span class="p">)</span>

    <span class="c1"># Call the pool to read the cube files</span>
    <span class="c1"># Close the pool </span>
    <span class="n">pool</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c1"># If we are to visualize the cubefiles, then we should compute the grid-mesh before hand to save time later</span>
    <span class="k">if</span> <span class="n">do_cube_visualization</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># This phase_factor_visual contains the phase factor correction for each state</span>
        <span class="c1"># and is used to plot the cubes phase corrected</span>
        <span class="n">phase_factor_visual</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span> <span class="p">(</span> <span class="n">max_band</span> <span class="o">-</span> <span class="n">min_band</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">)</span>
        <span class="c1"># Update the params with phase_factor_visual</span>
        <span class="n">params</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;phase_factor_visual&quot;</span><span class="p">:</span><span class="n">phase_factor_visual</span><span class="p">})</span>
        <span class="c1"># The states which were set to be plotted</span>
        <span class="n">states_to_be_plotted</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;states_to_be_plotted&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span> <span class="p">):</span>
            <span class="n">states_to_be_plotted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="nb">int</span><span class="p">(</span> <span class="n">state</span> <span class="p">)</span> <span class="p">)</span>
        <span class="c1"># Update the params for states_to_be_plotted</span>
        <span class="n">params</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;states_to_be_plotted&quot;</span><span class="p">:</span><span class="n">states_to_be_plotted</span><span class="p">})</span>
        <span class="c1"># Plot the cubes using VMD</span>
        <span class="n">cube_file_methods</span><span class="o">.</span><span class="n">plot_cubes</span><span class="p">(</span> <span class="n">params</span> <span class="p">)</span>

    <span class="c1"># After reading the cubefiles for curr_step, we should delete them to be memory efficient</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Removing cubefiles&quot;</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;rm cubefiles/*&quot;</span><span class="p">)</span>

    <span class="c1"># Froming the hvib_ks_re with energies for the first step in the job.</span>
    <span class="c1"># This will extract the Kohn-Sham energies and total energy from the CP2K log files and forms the Hvib_real</span>
    <span class="n">hvib_ks_re</span><span class="p">,</span> <span class="n">total_energy</span> <span class="o">=</span> <span class="n">form_Hvib_real</span><span class="p">(</span> <span class="n">params</span> <span class="p">)</span>
    <span class="c1"># Extracting the energies from Hvib_real matrices</span>
    <span class="n">E_ks_re</span> <span class="o">=</span> <span class="n">data_conv</span><span class="o">.</span><span class="n">nparray2CMATRIX</span><span class="p">(</span> <span class="n">hvib_ks_re</span> <span class="p">)</span>
    <span class="c1"># Appending the Kohn-Sham and total energies of this step in the E_ks_job and total_energies_job</span>
    <span class="n">E_ks_job</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">E_ks_re</span> <span class="p">)</span>
    <span class="n">total_energies_job</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">total_energy</span> <span class="p">)</span>

    <span class="k">if</span> <span class="n">completion_level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using completion level &gt; 0&quot;</span><span class="p">)</span>
        <span class="c1"># Get the excitation analysis output</span>
        <span class="n">excitation_energies</span><span class="p">,</span> <span class="n">ci_basis_raw</span><span class="p">,</span> <span class="n">ci_coefficients_raw_unnorm</span><span class="p">,</span> <span class="n">spin_components</span> <span class="o">=</span> <span class="n">get_excitation_analysis_output</span><span class="p">(</span> <span class="n">params</span> <span class="p">)</span>
        <span class="c1"># Normalize CI coefficients</span>
        <span class="n">ci_coefficients_raw_norm</span> <span class="o">=</span> <span class="n">normalize_ci_coefficients</span><span class="p">(</span><span class="n">ci_coefficients_raw_unnorm</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Printing excitation_analysis_output&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;excitation_energies = &quot;</span><span class="p">,</span> <span class="n">excitation_energies</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ci_basis_raw = &quot;</span><span class="p">,</span> <span class="n">ci_basis_raw</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ci_coefficients_raw_unnorm = &quot;</span><span class="p">,</span> <span class="n">ci_coefficients_raw_unnorm</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;spin_components = &quot;</span><span class="p">,</span> <span class="n">spin_components</span><span class="p">)</span>
        <span class="c1">#sys.exit(0)</span>

        <span class="c1"># Extract the uniquie SD basis states from the ci basis states</span>
        <span class="k">for</span> <span class="n">ci_basis_state_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">ci_basis_raw</span> <span class="p">)</span> <span class="p">):</span>
            <span class="k">for</span> <span class="n">sd_basis_state_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">ci_basis_raw</span><span class="p">[</span> <span class="n">ci_basis_state_index</span> <span class="p">]</span> <span class="p">)</span> <span class="p">):</span>
                <span class="n">sd_basis_state_and_spin</span> <span class="o">=</span> <span class="p">[</span> <span class="n">ci_basis_raw</span><span class="p">[</span> <span class="n">ci_basis_state_index</span> <span class="p">][</span> <span class="n">sd_basis_state_index</span> <span class="p">]</span> <span class="p">,</span> <span class="n">spin_components</span><span class="p">[</span> <span class="n">ci_basis_state_index</span> <span class="p">][</span> <span class="n">sd_basis_state_index</span> <span class="p">]</span> <span class="p">]</span>
                <span class="k">if</span> <span class="n">sd_basis_state_and_spin</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sd_basis_states_unique</span><span class="p">:</span>
                    <span class="n">sd_basis_states_unique</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">sd_basis_state_and_spin</span> <span class="p">)</span>
        <span class="c1"># Printing the unique Slater determinants basis - this will help the user to </span>
        <span class="c1"># see which states are considered and check them</span>
        <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;Slater determinant basis states = &quot;</span><span class="p">,</span> <span class="n">sd_basis_states_unique</span> <span class="p">)</span>

        <span class="c1"># Appending the extracted data from excitation analysis in the _job variables</span>
        <span class="n">ci_basis_states_job</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">ci_basis_raw</span> <span class="p">)</span>
        <span class="n">ci_coefficients_job</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">ci_coefficients_raw_norm</span> <span class="p">)</span>
        <span class="n">ci_energies_job</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">excitation_energies</span> <span class="p">)</span>
        <span class="n">spin_components_job</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">spin_components</span> <span class="p">)</span>

    <span class="n">curr_step</span> <span class="o">+=</span> <span class="mi">1</span>


    <span class="c1">#########################################</span>
    <span class="c1"># All other steps after initial step for this job</span>
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nsteps_this_job</span><span class="o">-</span><span class="mi">1</span> <span class="p">):</span>

        <span class="c1"># Update the params with curr_step</span>
        <span class="n">params</span><span class="o">.</span><span class="n">update</span><span class="p">({</span> <span class="s2">&quot;curr_step&quot;</span><span class="p">:</span><span class="n">curr_step</span> <span class="p">})</span>

        <span class="c1"># Setting up the timer</span>
        <span class="n">timer1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">es_software</span> <span class="o">==</span> <span class="s2">&quot;cp2k&quot;</span><span class="p">:</span>

            <span class="c1"># Creating the CP2K input</span>
            <span class="n">CP2K_methods</span><span class="o">.</span><span class="n">CP2K_input_static</span><span class="p">(</span> <span class="n">cp2k_input_template</span><span class="p">,</span> <span class="n">project_name</span><span class="p">,</span> <span class="n">trajectory_xyz_filename</span><span class="p">,</span> <span class="n">curr_step</span> <span class="p">)</span>
            <span class="c1"># Run CP2K</span>
            <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;mpirun -np </span><span class="si">%d</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> -i </span><span class="si">%s</span><span class="s2">-</span><span class="si">%i</span><span class="s2">.inp -o logfiles/step_</span><span class="si">%d</span><span class="s2">.log &quot;</span><span class="o">%</span><span class="p">(</span> <span class="n">nprocs</span><span class="p">,</span> <span class="n">cp2k_exe</span><span class="p">,</span> <span class="n">project_name</span><span class="p">,</span> <span class="n">curr_step</span><span class="p">,</span> <span class="n">curr_step</span> <span class="p">)</span> <span class="p">)</span>
            <span class="c1"># Move all the pdos and cube files to one folder</span>
            <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;mv *.pdos pdosfiles&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">es_software</span> <span class="o">==</span> <span class="s2">&quot;gaussian&quot;</span><span class="p">:</span>
            <span class="n">Gaussian_methods</span><span class="o">.</span><span class="n">gaussian_input</span><span class="p">(</span> <span class="n">project_name</span><span class="p">,</span> <span class="n">curr_step</span><span class="p">,</span> <span class="n">gaussian_input_template</span><span class="p">,</span> <span class="n">trajectory_xyz_filename</span> <span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> &lt; </span><span class="si">%s</span><span class="s2">-</span><span class="si">%i</span><span class="s2">.gjf &gt; logfiles/step_</span><span class="si">%d</span><span class="s2">.log &quot;</span><span class="o">%</span><span class="p">(</span> <span class="n">gaussian_exe</span><span class="p">,</span> <span class="n">project_name</span><span class="p">,</span> <span class="n">curr_step</span><span class="p">,</span> <span class="n">curr_step</span> <span class="p">)</span> <span class="p">)</span>
            <span class="n">Gaussian_methods</span><span class="o">.</span><span class="n">cube_generator_gaussian</span><span class="p">(</span><span class="n">project_name</span><span class="p">,</span><span class="n">curr_step</span><span class="p">,</span><span class="n">ks_orbital_indicies</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ks_orbital_indicies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">nprocs</span><span class="p">,</span><span class="s1">&#39;../../sample_cube_file.cube&#39;</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;isUKS&quot;</span><span class="p">]))</span>

        <span class="k">elif</span> <span class="n">es_software</span> <span class="o">==</span> <span class="s2">&quot;dftb+&quot;</span><span class="p">:</span>

            <span class="nb">print</span><span class="p">(</span> <span class="s1">&#39;params[&quot;curr_step&quot;]&#39;</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;curr_step&quot;</span><span class="p">])</span>
            <span class="c1"># Set up the dftb+ input template.</span>
            <span class="n">DFTB_methods</span><span class="o">.</span><span class="n">make_dftb_input</span><span class="p">(</span> <span class="n">dftb_input_template</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;curr_step&quot;</span><span class="p">]</span>  <span class="p">)</span>
            <span class="c1"># Convert the xyz file for currstep to the .gen file format</span>
            <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;xyz2gen coord-&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;curr_step&quot;</span><span class="p">])</span><span class="o">+</span><span class="s2">&quot;.xyz&quot;</span><span class="p">)</span>
            <span class="c1"># Run the dftb+ program</span>
            <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;srun </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="p">(</span> <span class="n">dftbp_exe</span> <span class="p">)</span> <span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;mv band.out step_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">curr_step</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_ks.log&quot;</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;mv step_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">curr_step</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_ks.log logfiles/.&quot;</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;mv EXC.DAT EXC_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">curr_step</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;.DAT&quot;</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;mv EXC_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">curr_step</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;.DAT logfiles/.&quot;</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;mv TRA.DAT TRA_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">curr_step</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;.DAT&quot;</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;mv TRA_&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">curr_step</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;.DAT logfiles/.&quot;</span><span class="p">)</span>
            <span class="n">DFTB_methods</span><span class="o">.</span><span class="n">cube_generator_dftbplus</span><span class="p">(</span> <span class="n">project_name</span><span class="p">,</span> <span class="n">curr_step</span><span class="p">,</span> <span class="n">ks_orbital_indicies</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ks_orbital_indicies</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;/util/academic/dftbplus/19.1-arpack/bin/waveplot&quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;isUKS&quot;</span><span class="p">])</span> <span class="p">)</span>
  
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;mv *.cube cubefiles&quot;</span><span class="p">)</span>

        <span class="c1"># Print the Timing</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Elapsed time for step &quot;</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;curr_step&quot;</span><span class="p">],</span><span class="s2">&quot; was &quot;</span><span class="p">,</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">timer1</span><span class="p">)</span>

        <span class="c1"># Forming the hvib_ks_re the same as above</span>
        <span class="n">hvib_ks_re</span><span class="p">,</span> <span class="n">total_energy</span> <span class="o">=</span> <span class="n">form_Hvib_real</span><span class="p">(</span> <span class="n">params</span> <span class="p">)</span>
        <span class="c1"># Extracting the energies and appending them in _job variables</span>
        <span class="n">E_ks_re</span> <span class="o">=</span> <span class="n">data_conv</span><span class="o">.</span><span class="n">nparray2CMATRIX</span><span class="p">(</span> <span class="n">hvib_ks_re</span> <span class="p">)</span>
        <span class="n">E_ks_job</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">E_ks_re</span> <span class="p">)</span>
        <span class="n">total_energies_job</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">total_energy</span> <span class="p">)</span>

        <span class="c1">#============================== Computation of the overlap matrices=============================</span>
        <span class="c1"># Now, read in the cube files for steps step-1 and step</span>
        <span class="c1"># and form the S_ks and St_ks overlap matricies</span>
        <span class="n">cubefiles_curr</span><span class="p">,</span> <span class="n">S_ks_prev</span><span class="p">,</span> <span class="n">S_ks_curr</span><span class="p">,</span> <span class="n">St_ks</span> <span class="o">=</span> <span class="n">compute_cube_ks_overlaps</span><span class="p">(</span> <span class="n">cubefiles_prev</span><span class="p">,</span> <span class="n">params</span> <span class="p">)</span>
        <span class="c1"># replace the cubefiles_prev with the cubefiles_curr </span>
        <span class="c1"># with this we do not need to read the cubes twice</span>
        <span class="n">cubefiles_prev</span> <span class="o">=</span> <span class="n">cubefiles_curr</span>
        <span class="c1">#===============================================================================================</span>

        <span class="c1"># Plot the cube files using VMD</span>
        <span class="k">if</span> <span class="n">do_cube_visualization</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">row_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">St_ks</span><span class="p">)):</span>
                <span class="c1"># Multiplying the phase factor for each states which needs to be plotted</span>
                <span class="k">if</span> <span class="n">St_ks</span><span class="p">[</span><span class="n">row_index</span><span class="p">][</span><span class="n">row_index</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="n">phase_factor_visual</span><span class="p">[</span><span class="n">row_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">phase_factor_visual</span><span class="p">[</span><span class="n">row_index</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Update the params with phase_factor_visual</span>
            <span class="n">params</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;phase_factor_visual&quot;</span><span class="p">:</span><span class="n">phase_factor_visual</span><span class="p">})</span>
            <span class="c1"># Plot the cubes</span>
            <span class="n">cube_file_methods</span><span class="o">.</span><span class="n">plot_cubes</span><span class="p">(</span> <span class="n">params</span> <span class="p">)</span>

        <span class="c1"># Now remove all the cube files to be memory efficient</span>
        <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s2">&quot;rm cubefiles/*&quot;</span><span class="p">)</span>

        <span class="c1"># Appending the normalized overlap matrices in the _job variables</span>
        <span class="n">S_ks_job</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S_ks_prev</span><span class="p">)</span>
        <span class="n">St_ks_job</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">St_ks</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="n">nsteps_this_job</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">S_ks_job</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S_ks_curr</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">completion_level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Reading the excitation analysis output for step &quot;</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;curr_step&quot;</span><span class="p">])</span>
            <span class="c1"># Get excitation analysis output results</span>
            <span class="n">excitation_energies</span><span class="p">,</span> <span class="n">ci_basis_raw</span><span class="p">,</span> <span class="n">ci_coefficients_raw_unnorm</span><span class="p">,</span> <span class="n">spin_components</span> <span class="o">=</span> <span class="n">get_excitation_analysis_output</span><span class="p">(</span> <span class="n">params</span> <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Printing excitation_analysis_output&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;excitation_energies = &quot;</span><span class="p">,</span> <span class="n">excitation_energies</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ci_basis_raw = &quot;</span><span class="p">,</span> <span class="n">ci_basis_raw</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ci_coefficients_raw_unnorm = &quot;</span><span class="p">,</span> <span class="n">ci_coefficients_raw_unnorm</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;spin_components = &quot;</span><span class="p">,</span> <span class="n">spin_components</span><span class="p">)</span>
            <span class="c1"># Normalize the coefficients</span>
            <span class="n">ci_coefficients_raw_norm</span> <span class="o">=</span> <span class="n">normalize_ci_coefficients</span><span class="p">(</span><span class="n">ci_coefficients_raw_unnorm</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ci_coefficients_raw_norm = &quot;</span><span class="p">,</span> <span class="n">ci_coefficients_raw_norm</span><span class="p">)</span>
            <span class="c1"># Extract the uniquie SD basis states from the ci basis states</span>

            <span class="k">for</span> <span class="n">ci_basis_state_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">ci_basis_raw</span> <span class="p">)</span> <span class="p">):</span>
                <span class="k">for</span> <span class="n">sd_basis_state_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">ci_basis_raw</span><span class="p">[</span> <span class="n">ci_basis_state_index</span> <span class="p">]</span> <span class="p">)</span> <span class="p">):</span>
                    <span class="n">sd_basis_state_and_spin</span> <span class="o">=</span> <span class="p">[</span> <span class="n">ci_basis_raw</span><span class="p">[</span> <span class="n">ci_basis_state_index</span> <span class="p">][</span> <span class="n">sd_basis_state_index</span> <span class="p">]</span> <span class="p">,</span> <span class="n">spin_components</span><span class="p">[</span> <span class="n">ci_basis_state_index</span> <span class="p">][</span> <span class="n">sd_basis_state_index</span> <span class="p">]</span> <span class="p">]</span> 
                    <span class="k">if</span> <span class="n">sd_basis_state_and_spin</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sd_basis_states_unique</span><span class="p">:</span>
                        <span class="n">sd_basis_states_unique</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">sd_basis_state_and_spin</span> <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span> <span class="s2">&quot;The unique SD basis states = &quot;</span><span class="p">,</span> <span class="n">sd_basis_states_unique</span> <span class="p">)</span>

            <span class="c1"># Now append the extracted excitation analysis output in _job variables</span>
            <span class="n">ci_basis_states_job</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">ci_basis_raw</span> <span class="p">)</span>
            <span class="n">ci_coefficients_job</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>   <span class="n">ci_coefficients_raw_norm</span> <span class="p">)</span>
            <span class="n">ci_energies_job</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">excitation_energies</span> <span class="p">)</span>
            <span class="n">spin_components_job</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">spin_components</span> <span class="p">)</span>

        <span class="n">curr_step</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># We need to output the last step overlap and energies as well.</span>
    <span class="n">step</span> <span class="o">=</span> <span class="n">nsteps_this_job</span><span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nsteps_this_job</span> <span class="p">):</span>
        <span class="n">S_ks_job</span><span class="p">[</span><span class="n">step</span><span class="p">]</span>  <span class="o">=</span> <span class="n">data_conv</span><span class="o">.</span><span class="n">nparray2CMATRIX</span><span class="p">(</span>  <span class="n">S_ks_job</span><span class="p">[</span><span class="n">step</span><span class="p">]</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nsteps_this_job</span><span class="o">-</span><span class="mi">1</span> <span class="p">):</span>
        <span class="n">St_ks_job</span><span class="p">[</span><span class="n">step</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_conv</span><span class="o">.</span><span class="n">nparray2CMATRIX</span><span class="p">(</span> <span class="n">St_ks_job</span><span class="p">[</span><span class="n">step</span><span class="p">]</span> <span class="p">)</span>

    <span class="n">step3</span><span class="o">.</span><span class="n">apply_normalization</span><span class="p">(</span> <span class="n">S_ks_job</span><span class="p">,</span> <span class="n">St_ks_job</span> <span class="p">)</span>
    <span class="n">step3</span><span class="o">.</span><span class="n">apply_phase_correction</span><span class="p">(</span> <span class="n">St_ks_job</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nsteps_this_job</span> <span class="p">):</span>
        <span class="n">S_ks_job</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">()</span><span class="o">.</span><span class="n">show_matrix</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/S_ks_</span><span class="si">%d</span><span class="s2">_re&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">res_dir</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;istep&quot;</span><span class="p">])</span><span class="o">+</span><span class="n">step</span><span class="p">))</span>
        <span class="n">E_ks_job</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">()</span><span class="o">.</span><span class="n">show_matrix</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/E_ks_</span><span class="si">%d</span><span class="s2">_re&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">res_dir</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;istep&quot;</span><span class="p">])</span><span class="o">+</span><span class="n">step</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nsteps_this_job</span><span class="o">-</span><span class="mi">1</span> <span class="p">):</span>
        <span class="n">St_ks_job</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">()</span><span class="o">.</span><span class="n">show_matrix</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/St_ks_</span><span class="si">%d</span><span class="s2">_re&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">res_dir</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;istep&quot;</span><span class="p">])</span><span class="o">+</span><span class="n">step</span><span class="p">))</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">completion_level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Complete! Exiting for completion levels 0 or 1&quot;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1">#################################################################################################################</span>
    <span class="c1">#################################################################################################################</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Finished with all of the step. Now computing the overlap matrices and NACs in TD-DFPT level of theory...&quot;</span><span class="p">)</span>
    <span class="c1"># Now, time to compute S_sd and St_sd</span>
    <span class="c1"># Start by reindexing the unique Slater determinant basis. The current SD bases are not able to be read by Libra</span>
    <span class="n">sd_states_reindexed</span> <span class="o">=</span> <span class="n">reindex_cp2k_sd_states</span><span class="p">(</span> <span class="n">ks_orbital_homo_index</span><span class="p">,</span> <span class="n">ks_orbital_indicies</span><span class="p">,</span> <span class="n">sd_basis_states_unique</span><span class="p">,</span> <span class="n">sd_format</span><span class="o">=</span><span class="mi">2</span> <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The reindexed Slater determinants = </span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">sd_states_reindexed</span><span class="p">)</span>

    <span class="c1"># For each step, we must sort the set of unique Slater determinant states based on their energy</span>
    <span class="n">E_sd_job</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sd_states_reindexed_sorted</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sd_states_unique_sorted</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">SD_energy_corr</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">sd_states_reindexed</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nsteps_this_job</span> <span class="p">):</span>
        <span class="n">E_this_sd</span>  <span class="o">=</span> <span class="n">mapping</span><span class="o">.</span><span class="n">energy_mat_arb</span><span class="p">(</span> <span class="n">sd_states_reindexed</span><span class="p">,</span> <span class="n">E_ks_job</span><span class="p">[</span><span class="n">step</span><span class="p">],</span> <span class="n">SD_energy_corr</span> <span class="p">)</span>
        <span class="n">nstates_sd</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sd_states_reindexed</span><span class="p">)</span>
        <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="n">nstates_sd</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nstates_sd</span><span class="p">):</span>
            <span class="n">e</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span>  <span class="n">E_this_sd</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">state</span><span class="p">,</span><span class="n">state</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
        <span class="n">reindex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="n">E_sd_job</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>  <span class="n">CMATRIX</span><span class="p">(</span><span class="n">nstates_sd</span><span class="p">,</span><span class="n">nstates_sd</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">sd_states_reindexed_sorted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">[]</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reindex</span><span class="p">)):</span>
            <span class="n">E_sd_job</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>  <span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">,</span> <span class="n">E_this_sd</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>  <span class="nb">int</span><span class="p">(</span><span class="n">reindex</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">reindex</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">)</span>
            <span class="n">sd_states_reindexed_sorted</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">sd_states_reindexed</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="n">reindex</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">]</span> <span class="p">)</span>
        <span class="c1"># To omit the ground state, we will manually make this later. the below variable goes to make the T matrix</span>
        <span class="n">sd_states_unique_sorted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">[]</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">reindex</span><span class="p">)):</span>
            <span class="n">sd_states_unique_sorted</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">sd_basis_states_unique</span><span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="n">reindex</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span> <span class="p">]</span> <span class="p">)</span>


    <span class="c1"># For each step make S_sd and St_sd</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Making the S_sd and St_sd....&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nsteps_this_job</span> <span class="p">):</span>
        <span class="n">s_sd</span> <span class="o">=</span> <span class="n">step3</span><span class="o">.</span><span class="n">mapping</span><span class="o">.</span><span class="n">ovlp_mat_arb</span><span class="p">(</span>  <span class="n">sd_states_reindexed_sorted</span><span class="p">[</span><span class="n">step</span><span class="p">],</span> <span class="n">sd_states_reindexed_sorted</span><span class="p">[</span><span class="n">step</span><span class="p">],</span> <span class="n">S_ks_job</span><span class="p">[</span><span class="n">step</span><span class="p">],</span>  <span class="n">use_minimal</span><span class="o">=</span><span class="kc">False</span> <span class="p">)</span>
        <span class="n">S_sd_job</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">s_sd</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nsteps_this_job</span><span class="o">-</span><span class="mi">1</span> <span class="p">):</span>
        <span class="n">st_sd</span> <span class="o">=</span> <span class="n">step3</span><span class="o">.</span><span class="n">mapping</span><span class="o">.</span><span class="n">ovlp_mat_arb</span><span class="p">(</span>  <span class="n">sd_states_reindexed_sorted</span><span class="p">[</span><span class="n">step</span><span class="p">],</span> <span class="n">sd_states_reindexed_sorted</span><span class="p">[</span><span class="n">step</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">St_ks_job</span><span class="p">[</span><span class="n">step</span><span class="p">],</span>  <span class="n">use_minimal</span><span class="o">=</span><span class="kc">False</span> <span class="p">)</span>
        <span class="n">St_sd_job</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">st_sd</span> <span class="p">)</span>

    <span class="c1"># Output Slater determinant data to the res directory</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Outputting the SD overlaps and energies.&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nsteps_this_job</span> <span class="p">):</span>
        <span class="n">S_sd_job</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">()</span><span class="o">.</span><span class="n">show_matrix</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/S_sd_</span><span class="si">%d</span><span class="s2">_re&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">res_dir</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;istep&quot;</span><span class="p">])</span><span class="o">+</span><span class="n">step</span><span class="p">))</span>
        <span class="n">E_sd_job</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">()</span><span class="o">.</span><span class="n">show_matrix</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/E_sd_</span><span class="si">%d</span><span class="s2">_re&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">res_dir</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;istep&quot;</span><span class="p">])</span><span class="o">+</span><span class="n">step</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nsteps_this_job</span><span class="o">-</span><span class="mi">1</span> <span class="p">):</span>
        <span class="n">St_sd_job</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">()</span><span class="o">.</span><span class="n">show_matrix</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/St_sd_</span><span class="si">%d</span><span class="s2">_re&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">res_dir</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;istep&quot;</span><span class="p">])</span><span class="o">+</span><span class="n">step</span><span class="p">))</span>

    <span class="c1"># Now, we have computed the overlaps in the KS and SD bases. Now, we need to compute the SD2CI matrix for each step</span>
    <span class="c1"># Now, form the SD2CI matrix for each step</span>
    <span class="n">ci_coefficients</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Add one to the number of CI states because the ground state is not included yet</span>
    <span class="n">nSDs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">sd_basis_states_unique</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">nCIs</span> <span class="o">=</span> <span class="n">number_of_states</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">SD2CI</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Computing the NACs for single-particle and many-body wavefunctions....&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nsteps_this_job</span> <span class="p">):</span>

        <span class="c1"># Make the list of ci_coefficients for each step in the way Libra accepts</span>
        <span class="n">ci_coefficients</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">[]</span> <span class="p">)</span>
        <span class="c1"># Start with the ground state. This is not explicitly given by electronic strcture calculations</span>
        <span class="n">ci_coefficients</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">nSDs</span> <span class="p">)</span>
        <span class="n">ci_coefficients</span><span class="p">[</span><span class="n">step</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="c1"># For each ci state for this step</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="nb">len</span><span class="p">(</span> <span class="n">ci_coefficients_job</span><span class="p">[</span><span class="n">step</span><span class="p">]</span> <span class="p">)</span> <span class="p">):</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ci_coefficients</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">nSDs</span> <span class="p">)</span>
            <span class="c1"># Exclude ground state here in the index, that info is not explicitly contained </span>
            <span class="c1"># in the ci_coefficients_dynamics list from electronic strcture calculations</span>
            <span class="n">tmp_ci_basis_state_and_spin</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ci_coefficients_job</span><span class="p">[</span><span class="n">step</span><span class="p">][</span><span class="n">i</span><span class="p">])):</span>
                <span class="n">tmp_ci_basis_state_and_spin</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">[</span><span class="n">ci_basis_states_job</span><span class="p">[</span><span class="n">step</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="p">,</span> <span class="n">spin_components_job</span><span class="p">[</span><span class="n">step</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]]</span> <span class="p">)</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nSDs</span><span class="o">-</span><span class="mi">1</span> <span class="p">):</span>
                <span class="k">if</span> <span class="n">sd_states_unique_sorted</span><span class="p">[</span><span class="n">step</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="ow">in</span> <span class="n">tmp_ci_basis_state_and_spin</span><span class="p">:</span>   
                    <span class="c1"># ok, it has found a match, now what is the index?</span>
                    <span class="n">item_index</span> <span class="o">=</span> <span class="n">tmp_ci_basis_state_and_spin</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">sd_states_unique_sorted</span><span class="p">[</span><span class="n">step</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">ci_coefficients</span><span class="p">[</span><span class="n">step</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">ci_coefficients_job</span><span class="p">[</span><span class="n">step</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">item_index</span><span class="p">])</span>    
 
        <span class="n">SD2CI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">CMATRIX</span><span class="p">(</span> <span class="n">nSDs</span><span class="p">,</span> <span class="n">nCIs</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nSDs</span> <span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nCIs</span> <span class="p">):</span>
                <span class="n">SD2CI</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">ci_coefficients</span><span class="p">[</span><span class="n">step</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">+</span><span class="mf">0.0</span><span class="n">j</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">SD2CI</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">show_matrix</span><span class="p">(</span> <span class="s2">&quot;T_</span><span class="si">%s</span><span class="s2">.txt&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">step</span><span class="p">)</span> <span class="p">)</span>

    <span class="c1"># For each step make S_ci and St_ci</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Making the S_ci and St_ci matrices....&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nsteps_this_job</span> <span class="p">):</span>
        <span class="n">s_ci</span> <span class="o">=</span> <span class="n">SD2CI</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">H</span><span class="p">()</span>  <span class="o">*</span> <span class="n">S_sd_job</span><span class="p">[</span><span class="n">step</span><span class="p">]</span>  <span class="o">*</span> <span class="n">SD2CI</span><span class="p">[</span><span class="n">step</span><span class="p">]</span>
        <span class="n">S_ci_job</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">s_ci</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nsteps_this_job</span><span class="o">-</span><span class="mi">1</span> <span class="p">):</span>
        <span class="n">st_ci</span> <span class="o">=</span> <span class="n">SD2CI</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">H</span><span class="p">()</span> <span class="o">*</span> <span class="n">St_sd_job</span><span class="p">[</span><span class="n">step</span><span class="p">]</span> <span class="o">*</span> <span class="n">SD2CI</span><span class="p">[</span><span class="n">step</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">St_ci_job</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">st_ci</span> <span class="p">)</span>

    <span class="c1"># Now, compute the CI energy matrix at each-point and the mid-points</span>
    <span class="c1"># For each step</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Computing the CI energy matrices....&quot;</span><span class="p">)</span>
    <span class="n">ci_energies_job_cmatrix</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nsteps_this_job</span> <span class="p">):</span>
        <span class="n">ci_energies_job_cmatrix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">CMATRIX</span><span class="p">(</span> <span class="n">number_of_states</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">number_of_states</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">number_of_states</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ci_energies_job_cmatrix</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span> <span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">total_energies_job</span><span class="p">[</span><span class="n">step</span><span class="p">]</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ci_energies_job_cmatrix</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span> <span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">total_energies_job</span><span class="p">[</span><span class="n">step</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span> <span class="n">ci_energies_job</span><span class="p">[</span><span class="n">step</span><span class="p">][</span><span class="n">state</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">ev2Ha</span> <span class="p">)</span>  <span class="p">)</span>

    <span class="c1"># At the midpoints</span>
    <span class="n">ci_midpoint_energies</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nsteps_this_job</span><span class="o">-</span><span class="mi">1</span> <span class="p">):</span>
        <span class="n">total_energy_mid_point</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span> <span class="n">total_energies_job</span><span class="p">[</span><span class="n">step</span><span class="p">]</span> <span class="o">+</span> <span class="n">total_energies_job</span><span class="p">[</span><span class="n">step</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
        <span class="n">ci_midpoint_energies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">CMATRIX</span><span class="p">(</span> <span class="n">number_of_states</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">number_of_states</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">number_of_states</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">state</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ci_midpoint_energies</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span> <span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">total_energy_mid_point</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">midpoint_energy</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span> <span class="n">ci_energies_job</span><span class="p">[</span><span class="n">step</span><span class="p">][</span><span class="n">state</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">ci_energies_job</span><span class="p">[</span><span class="n">step</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">state</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
                <span class="n">ci_midpoint_energies</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span> <span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">total_energy_mid_point</span> <span class="o">+</span> <span class="p">(</span> <span class="n">midpoint_energy</span>  <span class="o">*</span> <span class="n">units</span><span class="o">.</span><span class="n">ev2Ha</span> <span class="p">)</span>  <span class="p">)</span>

    <span class="c1"># Are we to perform state reordering?</span>
    <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;perform_state_reordering&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">params2</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;do_state_reordering&quot;</span><span class="p">:</span><span class="nb">int</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;do_state_reordering&quot;</span><span class="p">]),</span> <span class="s2">&quot;state_reordering_alpha&quot;</span><span class="p">:</span><span class="nb">float</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;state_reordering_alpha&quot;</span><span class="p">])}</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Applying state reordering....&quot;</span><span class="p">)</span>
        <span class="n">step3</span><span class="o">.</span><span class="n">apply_state_reordering_general</span><span class="p">(</span> <span class="n">St_ci_job</span><span class="p">,</span> <span class="n">ci_midpoint_energies</span><span class="p">,</span> <span class="n">params2</span> <span class="p">)</span>

    <span class="c1"># Are we to perform phase corrections?</span>
    <span class="k">if</span> <span class="n">do_phase_corrections</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Applying phase corrections&quot;</span><span class="p">)</span>
        <span class="n">step3</span><span class="o">.</span><span class="n">apply_phase_correction_general</span><span class="p">(</span> <span class="n">St_ci_job</span> <span class="p">)</span>

    <span class="c1"># Output CI data to res directory</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Outputting the CI data to the res directory...&quot;</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nsteps_this_job</span> <span class="p">):</span>
        <span class="n">S_ci_job</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">()</span><span class="o">.</span><span class="n">show_matrix</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/S_ci_</span><span class="si">%d</span><span class="s2">_re&quot;</span>   <span class="o">%</span> <span class="p">(</span><span class="n">res_dir</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;istep&quot;</span><span class="p">])</span><span class="o">+</span><span class="n">step</span><span class="p">))</span>
        <span class="n">ci_energies_job_cmatrix</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">()</span><span class="o">.</span><span class="n">show_matrix</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/E_ci_</span><span class="si">%d</span><span class="s2">_re&quot;</span>   <span class="o">%</span> <span class="p">(</span><span class="n">res_dir</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;istep&quot;</span><span class="p">])</span><span class="o">+</span><span class="n">step</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nsteps_this_job</span><span class="o">-</span><span class="mi">1</span> <span class="p">):</span>
        <span class="n">St_ci_job</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="p">()</span><span class="o">.</span><span class="n">show_matrix</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/St_ci_</span><span class="si">%d</span><span class="s2">_re&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">res_dir</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;istep&quot;</span><span class="p">])</span><span class="o">+</span><span class="n">step</span><span class="p">))</span>

    <span class="c1"># Now, compute the CI NACs and compute the CI Hvib</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Computing and outputting the CI NACs...&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="n">nsteps_this_job</span><span class="o">-</span><span class="mi">1</span> <span class="p">):</span> 
        <span class="n">ci_nacs</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span>  <span class="mf">0.5</span><span class="n">j</span> <span class="o">/</span> <span class="n">dt</span> <span class="p">)</span> <span class="o">*</span> <span class="n">CMATRIX</span> <span class="p">(</span> <span class="p">(</span> <span class="n">St_ci_job</span><span class="p">[</span><span class="n">step</span><span class="p">]</span> <span class="o">-</span> <span class="n">St_ci_job</span><span class="p">[</span><span class="n">step</span><span class="p">]</span><span class="o">.</span><span class="n">H</span><span class="p">()</span> <span class="p">)</span><span class="o">.</span><span class="n">real</span><span class="p">()</span> <span class="p">)</span>    
        <span class="n">ci_hvib</span> <span class="o">=</span> <span class="n">ci_midpoint_energies</span><span class="p">[</span><span class="n">step</span><span class="p">]</span> <span class="o">+</span> <span class="n">ci_nacs</span>
        <span class="n">ci_hvib</span><span class="o">.</span><span class="n">real</span><span class="p">()</span><span class="o">.</span><span class="n">show_matrix</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/Hvib_ci_</span><span class="si">%d</span><span class="s2">_re&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">res_dir</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;istep&quot;</span><span class="p">])</span><span class="o">+</span><span class="n">step</span><span class="p">))</span>
        <span class="n">ci_hvib</span><span class="o">.</span><span class="n">imag</span><span class="p">()</span><span class="o">.</span><span class="n">show_matrix</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/Hvib_ci_</span><span class="si">%d</span><span class="s2">_im&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">res_dir</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;istep&quot;</span><span class="p">])</span><span class="o">+</span><span class="n">step</span><span class="p">))</span>


    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;All steps were done successfully for this job!&quot;</span><span class="p">)</span></div>

 
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019, Alexey V. Akimov.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>